---
title: Knowledge Acquisition
date: 2007-02-06T12:00:00-05:00
---

  
  <p><a href="http://journals.aol.com/panzerjohn/abstractioneer/entries/2007/02/05/the-essential-hardness-of-programming/1402">John Panzer</a>:</p>
<blockquote><p>
Software development is a knowledge acquisition activity, not a manufacturing activity.
</p></blockquote>
<p>I frequently get asked why I write
<a href="http://bitworking.org/projects/robaccia/">my own frameworks</a>, 
<a href="http://bitworking.org/projects/1812/">my own blogging software</a>, 
<a href="http://bitworking.org/projects/apptestclient/">my own blogging client</a>, 
even my own <a href="http://bitworking.org/projects/cascon06/128.html">presentation software</a>. That's the answer: knowledge acquisition.</p>
  <div class="commentContent" id="X2">
    Yeah, I'm with you.  Frequently the activity of development is more worthwhile than the end result and also I tend to try to do a very quick first iteration on a design/implementation to extract lessons for the second and later iterations.  I wrote a <a href="http://www-03.ibm.com/developerworks/blogs/page/BillHiggins?entry=coding_to_learn">post</a> on this topic recently.
    <p class="commentByLine">Posted by
       <a href="http://billhiggins.us/weblog/">Bill Higgins</a> on <a href="#X2" title="2007-02-06T17:15:47.697645">2007-02-06</a>
    </p>
</div><div class="commentContent" id="X3">
    <p>A few thoughts. I find that I immediately doubt the credibility or seriousness of anything published with an AOL logo on it. What a brand problem.</p>
<p>Second, it seems that your response is a veiled refutation of John's premise that:</p>
<blockquote>there are some people who just aren't good at finding prior solutions, or at understanding them once found, and they may contribute to unnecessary re-creation of software, increasing both cost and risk to larger projects.  But they're not the norm</blockquote>
<p>I really like the idea of programming as knowledge acquisition. But the bit about "unnecessary re-creation of software" seems to contradict his whole piece and smacks of a little elitism if you ask me.</p>
    <p class="commentByLine">Posted by
       <a href="http://justinsomnia.org">Justin Watt</a> on <a href="#X3" title="2007-02-07T01:32:58.561393">2007-02-07</a>
    </p>
</div><div class="commentContent" id="X4">
    I suppose whether a particular re-creation is necessary depends on whether you're an 'engineer' or a 'scientist'.  I was talking from the 'engineering' point of view, where the primary goal is to solve a problem.  Here knowledge acquisition is just a prerequisite and unnecessary re-creation doesn't advance your goal.  If you are being a 'scientist' and your primary goal is to acquire knowledge, then re-creation is fine and actually is a foundation of the scientific method.  Sometimes you have to go back and forth between the two roles of course.

Perhaps I misinterpreted Scott Rosenberg and he was really saying that the big problem is that programmers behave like scientists, when their projects need them to behave like engineers.  The root problem then is not competence but a conflict of interest.  I just don't think this is a key problem.  That is, it's a real issue, but I don't see it as the key reason why software projects take so long or fail so often.  I actually see the reverse problem a lot more (engineers trying to get a quick solution and not recognizing when it's time to step back and put on a scientist hat for a while).
    <p class="commentByLine">Posted by
       <a href="http://journals.aol.com/panzerjohn/abstractioneer">John Panzer</a> on <a href="#X4" title="2007-02-07T05:15:31.401373">2007-02-07</a>
    </p>
</div><div class="commentContent" id="X5">
    <cite>Software development is a knowledge acquisition activity, not a manufacturing activity.</cite> 

This truth has been said before. There is one Alain Perlis epigram that says something like "When we try to make computers learn, it turns out that we learn and computers don't". In the Mythical Man Month you can read similar conclusion when discussion turns into second system effect. 

I think there is many examples of wrong kind of knowledge acquisition. You learn something by programming that you could have learned more quickly from the books or from studying how old programs do it. When you use both these sources and then  write your programs you can learn something that others have not learned before. I think software engineering field lacks memory. It is frustrating to see that field is not moving forward but people just discover same solutions over and over.
    <p class="commentByLine">Posted by
       <a href="mailto:notany@gmail.com">Nick Nolan</a> on <a href="#X5" title="2007-02-08T18:37:39.054323">2007-02-08</a>
    </p>
</div><div class="commentContent" id="X6">
    In truth it is both: a balance between real world needs and theoretical perfection.
    <p class="commentByLine">Posted by
       <a href="http://www.mikecantelon.com">Mike Cantelon</a> on <a href="#X6" title="2007-02-08T21:10:53.744091">2007-02-08</a>
    </p>
</div><div class="commentContent" id="X7">
    I think building one's one software when there are suitable options out there would happen less often if open source also meant open architecture and open documentation.  If I want to know the different elements required in building forums or a querying system or whatnot, I either have to dig deep into someone else's source code (which probably lacks comments and statistically isn't all that great), or do it on my own.  The stress and annoyance of looking at other people's code without a birds-eye view from which to work is fairly significant.

There needs to be more information like this: http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html

Thoughts?
    <p class="commentByLine">Posted by
       <a href="http://luke.breuer.com">Luke</a> on <a href="#X7" title="2007-02-09T14:56:00.300517">2007-02-09</a>
    </p>
</div><div class="commentContent" id="X8">
    I have been doing my own stuff (you name it, me's done it). And I have never understood why people look at it as bad to do what has already been done. You can't understand the Standard Template Library of C++, unless you've cloned it. You can't know your *NIX real good, unless you've cloned it. You can't know your typing real good, unless you've typed! (Not just read what has been typed.)<br /><br />

I have argued this and frothed at the mouth, and thought I was the only one who saw this. Wrong, of course.<br /><br />

And, don't let anybody tell you it is for those who are learning. No! Learning never ends, and every time you write new code, you learn. Even if what you are learning is a new bug (or the lack of a feature) in your own programming language.
<br /><br />
(Removed my address, because I think it may be reaped by bots - can it? Here, anyway, of you want it: revence27 at g m a i l dot com)
    <p class="commentByLine">Posted by
       <a href="mailto:removed_my_address@sorry_for_this.com">Revence 27</a> on <a href="#X8" title="2007-02-10T11:35:33.526349">2007-02-10</a>
    </p>
</div>
  

