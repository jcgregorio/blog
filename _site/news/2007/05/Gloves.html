<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Gloves</title>
  <meta name="description" content="Last time I talked about the creation of Robaccia I got to the point of a working framework and just waved my hands and said you could keep going and &quot;just&quot; ...">
  <meta name="google-site-verification" content="vZSL2JjLp0S_VXH743XRWWgko2D6B124A8pUAqT4FFk" />

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://bitworking.org/news/2007/05/Gloves">
  <link rel="alternate" type="application/atom+xml" title="BitWorking" href="/news/feed/">
  <link rel="author" href="/about/">
  <link href="https://bitworking.org/u/webmention" rel="webmention" />
  <script async defer src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML'></script>
  <meta name="twitter:site"    content="@bitworking">
  <meta name="twitter:creator" content="@bitworking">
  <meta name="twitter:title"   content="Gloves">
  <meta name="twitter:description" content="  <p>
Last time I talked about the creation of <a href="http://bitworking.org/news/Why_so_many_Python_web_frameworks">Robaccia</a>
I got to the point of a working framework and just waved
my hands and said you could keep going and "just" add conventions. 
I have pointed out that <a href="http://fishbowl.pastiche.org/2003/10/07/just_is_a_fourletter_word">"just" is a dangerous word</a>, 
so let's walk through the rest of the steps
to building a Rails/Django-like web framework.
</p>
<p><b>Update:</b> Just so there's no confusion, the title of this post comes from 
<a href="http://worsethanfailure.com/Articles/The_Complicator_0x27_s_Gloves.aspx">The Complicator's Gloves</a>.</p>
  <p>They key point of adding 'conventions'  is to take 
   a load off the user. You need to actually remove two kinds
   of load, cognitive and manual. Cognitive load is the number
   of concepts you need to hold in your head. The fewer the number of 
   concepts, and the more uniformly they are applied, the easier the
   system will be to use. Manual load is just the amount of 
   manual stuff, like typing, that you need to do. Why should
   I have to manually create a directory structure when a computer
   is capable of doing that? 
</p>
<h3>Motivation</h3>
<p class="aside">Before diving into lots of code and details
  let's clarify what I'm trying to accomplish here. I am <b>not</b>
  trying to write Rails for Python. My mission in creating this 
  software, and this write-up, is to lay out the core ideas 
  of constraints, cognitive load, and manual load, and how to apply 
  them to create a Rails/Django-like web framework, in the hopes 
  that it is helpful, so that <i>you</i> can 
  use it to create your own Rails-like framework in your language
  of choice.
</p>
<p class="aside">In this example I make some design decisions that
might seem a bit extreme. They are. You probably should make 
different choices for your web framework based on your programming
language and problem domain.
</p>
<h3>The Happy Path</h3>
<p>I am going to borrow a term from testing, <a href="http://en.wikipedia.org/wiki/Happy_path">Happy Path</a>,
   and use it in the context of creating our conventions. We need to pick
   a happy path when using our framework, and we need to knock down as many
   barriers, and make things as easy as possible, as long as users stick
   to that happy path.
</p>
<h3>Design</h3>
<p>If you are familiar with Ruby on Rails or Django then
the development story should be familiar. Here's the 
core of our design document. Creating an employee
application should consist of the following steps:</p>
<pre>
    $ robaccia createproject myproject 
    $ cd myproject 
    $ robaccia addmodelview employees <i># Creates  view, templates, and model.</i>
    $ gvim ./models/employees.py      <i># Add table columns.</i>
    $ robaccia createdb
    $ robaccia run
    $ firefox http://localhost:8080/employees/
</pre>
<p>
Of course, we may already have a model in place, and want
to just create another view on that model. Adding a view-only collection
should be as simple as:
</p>
<pre>
    $ robaccia addview employees
    $ robaccia run
    $ firefox http://localhost:8080/employees/
</pre>
<h3>Preliminaries</h3>
<p>
Currently Robaccia consists of a couple modules and a 
bunch of conventions for how to lay out a project.
They include the files: 
</p>
<ul>
<li><code>model.py</code> - One or more models expressed in SQLAlchemy Tables.</li>
<li><code>view.py</code> - One or more views, implemented as WSGI applications.</li>
<li><code>urls.py</code> - A single instance of a selector object that maps URIs to the WSGI applications in <code>view.py</code>.</li>
<li><code>templates</code> - A directory of Kid templates to be used to format the responses from the view applications.</li>
<li><code>dbconfig.py</code> - Configuration for the SQLAlchemy Tables in model.py</li>
</ul>
<p>
To accomodate making more complex projects we'll update most of those
files to be directories, and add another directory for log files:
</p>
<pre>
    /views
    /templates
    /models
    /logs
</pre>
<p>We'll leave <code>urls.py</code> as a file, but just rename it 
to <code>dispacher.py</code>, because while it does match
based on the incoming URI, it also matches on the request method,
so let's name it for what it does.</p>
<p>So let's look at what the directory structure we
 have for a Robaccia based application:
 </p>
<pre>
views/
models/
templates/
logs/
dispatcher.py
</pre>
<p>And if we add a new resource to our application we distribute
 the model, view, and template files under each of those directories.
 </p>
<pre>
views/<b>name</b>.py
models/<b>name</b>.py
templates/<b>name</b>/list.html
templates/<b>name</b>/retrieve.html
...
logs/
</pre>
<p>
  Now Robaccia, using selector, allows you to dispatch to any
  view from any form of URI and any method. We need to simplify
  that, by adding constraints, and guide those constraints
  using a conceptual model. You can't possibly be surprised
  that I would choose a RESTful collection as an organizing principle.
  In particular, we'll assume that everything you want to create
  will fit into <a href="http://bitworking.org/news/wsgicollection">wsgicollection</a>.
  We will, obviously, build in an escape hatch, but RESTful
  collections will be our happy path.
</p>
<p>
  In general, using the notation of selector, we are looking at URIs 
  of the form:
  </p>
<pre><code> /...people/[{id}][;{noun}] </code></pre>
<p>
  And dispatching requests to URIs of that form to functions with nice names:
  </p>
<pre><code>  GET    /people               list()
  POST   /people               create()
  GET    /people/1             retrieve()
  PUT    /people/1             update()
  DELETE /people/1             delete()
  GET    /people;create_form   get_create_form()
  GET    /people/1;edit_form   get_edit_form()
  </code></pre>
<p>
We'll wrap all those target functions up into a single class and make
instances of those classes a WSGI application:
</p>
<pre><code><span class="PreProc">from</span> wsgicollection <span class="PreProc">import</span> Collection
<span class="Statement">class</span> <span class="Identifier">People</span>(Collection):
    <span class="Comment"># GET /people/</span>
<span class="Statement">def</span> <span class="Identifier">list</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># POST /people/</span>
<span class="Statement">def</span> <span class="Identifier">create</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># GET /people/1</span>
<span class="Statement">def</span> <span class="Identifier">retrieve</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># PUT /people/1</span>
<span class="Statement">def</span> <span class="Identifier">update</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># DELETE /people/1</span>
<span class="Statement">def</span> <span class="Identifier">delete</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># GET /people/;create_form</span>
<span class="Statement">def</span> <span class="Identifier">get_create_form</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># POST /people/1;comment_form</span>
<span class="Statement">def</span> <span class="Identifier">post_comment_form</span>(environ, start_response):
        <span class="Statement">pass</span>
</code></pre>
<p>So if a collection is our organizing principle, what about our URI structure?
Let's keep it simple and presume everything will fall into a simple
URI template:
</p>
<pre><code>
/{view:alnum}/[{id:unreserved}][;{noun:unreserved}]
</code></pre>
<p>That is, each {view} represents a collection, and {view}/{id} is a member
of that collection. That's very simple and we have introduced a number of 
constraints by restricting ourselves to this URI structure:
</p>
<dl>
<dt>Content type</dt>
<dd>We presume that this collection has a single content type, such
       as HTML, or JSON. There is no provision for having a single collection
       serve up content in different media types. If you want to handle different
       media types then you can create two views that reference the same
       underlying model.
    </dd>
<dt>Nesting</dt>
<dd>The namespace is very flat, not allowing nesting of 
    resources beyond the simple collection. For example, if you were
    creating blogging application, you couldn't create 
    the main blog as a collection of entries, <code>/blog/{id}</code>,
    and then have a collection of comments for each blog entry, ala
    <code>/blog/{id}/comments/{commentid}</code>, but you could 
    have a collection that worked on all comments received, 
    <code>/comments/{id}</code>. Again, you can certainly
    do the nested collections for comments with the tools we are 
    going to supply, but that is not on the happy path. 
    </dd>
</dl>
<p>
  Also, in the intervening time since Robaccia was initially released
  I've written my own version of selector, 
  <a href="http://bitworking.org/news/163/WSGIDispatcher">wsgidispatcher</a>,
  so we'll switch to using that. The activity around Kid has diminished
  and moved mostly to Genshi, so we will also migrate to Genshi for templating.
</p>
<p>
    RESTful collections, and a highly constrained URI scheme, are the concepts
    we're using to reduce cognitive load.
    On the manual load side, we'll build some command line tools
    to automate the generation of stubs and directories.
</p>
<h3>Implementation</h3>
<p>
To fulfill our design we'll take the current Robaccia through a number
of incremental steps. The first step is modularization.
</p>
<h4>Modularize robaccia</h4>
<p>
We need to convert Robaccia from a set of conventions and 
a few lines of code into a library on it's own. First, we consolidate
all the code into a single installable module. We'll also create a stub
for the 'robaccia-admin' program, the one we'll eventually use to create 
the skeleton for project. 
</p>
<pre> 
   robaccia.py =&gt; robaccia/__init__.py # controversial in some quarters
   wsgidispatcher.py =&gt; robaccia/wsgidispatcher.py
   wsgicollection.py =&gt; robaccia/wsgicollection.py
   mimetypes.py =&gt; robaccia/mimetypes.py
</pre>
<p>
The only change that this requires in our code is a change in the imports
for wsgicollection and wsgidispatcher.
</p>
<p>
Now let's create a <code>setup.py</code> so our new module can be installed.
This uses the built-in <a href="http://docs.python.org/lib/module-distutils.html">distutils</a> library, and the configuration
  file is really a Python program.
</p>
<pre>
[<a href="http://robaccia.googlecode.com/svn/trunk/setup.py">setup.py</a>]
</pre>
<p>
Note that this setup file not only installs the robaccia library, but 
also the 'robaccia-admin' program.
</p>
<h4>robaccia-admin</h4>
<p>
We want to create a program that we can run that takes 
commands as arguments, just like 'svn' or 'bzr'. In addition we
want help, and also, like 'bzr', a way to make the
command set extensible. At the very least, we want to make
adding new command to 'robaccia-admin' easy. The simplest thing
that could possibly work is to have the command name 
match a method name in the module, and just look them up 
on the fly. 
</p>
<h3><tt>robaccia-bin</tt></h3>
<pre><code>members = globals()
<span class="Statement">if</span> __name__ == "<span class="Constant">__main__</span>":
    <span class="Statement">try</span>:
        cmd = sys.argv[1]
    <span class="Statement">except</span>:
        cmd = "<span class="Constant">help</span>"
    args = sys.argv[2:]
    <span class="Statement">if</span> cmd <span class="Statement">not</span> <span class="Statement">in</span> members <span class="Statement">or</span>  
             cmd.startswith("<span class="Constant">_</span>") <span class="Statement">or</span> (<span class="Statement">not</span> callable(members[cmd])):
        cmd = "<span class="Constant">help</span>"
    members[cmd](args)
</code></pre>
<p>
Note that if a command isn't found in 'members', then
we assume the command "help". That gets us running commands, but
how do we do help? We need two kinds of help, a short message 
on how to use a command, used when we request a list of commands, and
a longer help description for when we want help on a single command.
Also, I don't want to write a separate help file.
</p>
<p>In Python if the first thing in your method is a string, then that
string is available via the __doc__ attribute. We'll put in place
a convention that the first line of the doc string is a short
description, and the whole doc string will be used for help
on that command. So, as an example, here is the implementation
for the 'commands' command. Run 'robaccia-admin commands' to get a list
of all the commands that the robaccia program supports. 
</p>
<h3><tt>robaccia-bin</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">commands</span>(args):
    """<span class="Constant">robaccia commands     </span>
<span class="Constant"></span>
<span class="Constant">List all known commands that robaccia knows.</span>
"""
    <span class="Statement">for</span> name <span class="Statement">in</span> members:
        <span class="Statement">if</span> <span class="Statement">not</span> name.startswith("<span class="Constant">_</span>") <span class="Statement">and</span> callable(members[name]):
            <span class="Statement">print</span> members[name].__doc__.splitlines()[0]
</code></pre>
<p>
So now we can add the 'createproject' command. The 'createproject' command just
creates a directory structure populated with some default files. Looking back
into 'setup.py' you can see the 'package_data' parameter, which is a list
of non-source files that can be packaged with the library. 
We will stuff a skeleton project directory structure in there
and copy it over when we create a project.  We'll leverage Python's 
ability to introspect here, as each module has
a __file__ attribute which is the location of the source file, and 
we will use that to construct a path to the template files.
</p>
<h3><tt>robaccia-bin</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">createproject</span>(args):
    <span class="Normal">"""</span><span class="Constant">robaccia createproject &lt;name&gt;   </span>
<span class="Constant">Creates a new project directory structure.</span>
<span class="Constant">The target directory must not exist.</span>
<span class="Constant"></span><span class="Normal">"""</span>
<span class="Statement">try</span>:
        name = args[0]
    <span class="Statement">except</span>:
        sys.exit(<span class="Normal">"</span><span class="Constant">Error: Missing required parameter &lt;name&gt;.</span><span class="Normal">"</span>)
    <span class="Statement">if</span> os.path.exists(name):
        sys.exit(<span class="Normal">"</span><span class="Constant">Error: Directory '%s' already exists</span><span class="Normal">"</span> % name)
    template_dir = os.path.abspath(
       os.path.join(robaccia.__file__, <span class="Normal">"</span><span class="Constant">..</span><span class="Normal">"</span>, <span class="Normal">"</span><span class="Constant">templates</span><span class="Normal">"</span>, <span class="Normal">"</span><span class="Constant">project</span><span class="Normal">"</span>)
    )
    shutil.copytree(template_dir, name)
</code></pre>
<h4>addview</h4>
<p>At this point let's skip to our second scenario and
  implement the 'addview' command. We'll go back later and 
  add the 'addmodelview' command.
</p>
<p>We'd like to keep the cognitive load as small as possible. 
If you look at the original implementation of Robaccia, each 
view had to render it's own template:</p>
<p><b>!! This is the old way, what were trying to replace  !!</b></p>
<pre><code>
<span class="PreProc">import</span> selector
<span class="PreProc">import</span> view
urls = selector.Selector()
urls.add(<span class="Normal">'</span><span class="Constant">/blog/</span><span class="Normal">'</span>, GET=view.list)
urls.add(<span class="Normal">'</span><span class="Constant">/blog/{id}/</span><span class="Normal">'</span>, GET=view.member_get)
</code></pre>
<p><b>!! This is the old way, what were trying to replace  !!</b></p>
<pre><code>
<span class="Statement">def</span> <span class="Identifier">list</span>(environ, start_response):
    rows = model.entry_table.select().execute()
    <span class="Statement">return</span> robaccia.render(start_response, <span class="Normal">'</span><span class="Constant">list.html</span><span class="Normal">'</span>, locals())
</code></pre>
<p>WSGICollection helps by adding an idiom and removing the need
to map each request URI and method to a WSGI application, but we 
can do better. We can take <code>robaccia.render()</code>
and presume that every renderer will conform to that signature. 
Since we have a convention for how files will be laid out, we can
do even more work, we can look up the template to render using
the name of the WSGICollection that was called, and the name of the 
member function that was called.
The only piece of information we are missing is the file extension
of the template, so we will have to pass that in also.
</p>
<p>What we want, for example, is that if we add a collection 'fred':
<pre>
   /views/<b>fred</b>.py
   /templates/<b>fred</b>/list.html
   /templates/<b>fred</b>/retreive.html
</pre>
</p><p>
Then a GET to <tt>/fred/</tt> will 
end up calling <code>views.fred.app.list()</code>, and the template
<tt>/templates/<b>fred</b>/list.html</tt> will be rendered.
</p>
<p>That's fine default behavior, but we need a way to signal whether we want
the default rendering to occur, of the collection view member function
has decided to over-ride the default behavior and do it's own processing.
</p>
<p>In normal processing a wsgicollection member function
returns an iterable. We can look for things besides 
iterables to indicate that we should look for a template and render it.
The simplest thing is to look for a dictionary, since that is what you
pass into a template to get rendered. We can also accept 'None'
in the response and convert that into some sort of acceptable dictionary to be
passed into the templating engine.
</p>
<p>Here is the implementation for DefaultCollection, which implements the above design:
</p>
<h3><tt>defaultcollection.py</tt></h3>
<pre><code><span class="PreProc">from</span> wsgicollection <span class="PreProc">import</span> Collection
<span class="PreProc">import</span> os
<span class="Statement">class</span> <span class="Identifier">DefaultCollection</span>(Collection):
    <span class="Statement">def</span> <span class="Identifier">__init__</span>(self, ext, renderer):
        Collection.__init__(self)
        self._ext = ext
        self._renderer = renderer
    <span class="Statement">def</span> <span class="Identifier">__call__</span>(self, environ, start_response):
        response = Collection.__call__(self, environ, start_response)
        <span class="Statement">if</span> response == None:
            <span class="Statement">if</span> self._id:
                response = {<span class="Normal">'</span><span class="Constant">id</span><span class="Normal">'</span>: self._id}
            <span class="Statement">else</span>:
                response = {}
        <span class="Statement">if</span> isinstance(response, dict):
            view = environ[<span class="Normal">'</span><span class="Constant">wsgiorg.routing_args</span><span class="Normal">'</span>][1].get(<span class="Normal">'</span><span class="Constant">view</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">.</span><span class="Normal">'</span>)
            template_file = os.path.join(view, self._function_name + <span class="Normal">"</span><span class="Constant">.</span><span class="Normal">"</span> + self._ext)
            <span class="Statement">return</span> self._renderer(environ, start_response, template_file, response)
        <span class="Statement">else</span>:
            <span class="Statement">return</span> response
</code></pre>
<p>Note that we hand off most of the work to wsgicollection.Collection, and
then if the response is a dictionary we look up the template 
and pass the name into the renderer. The only other thing to note is that
the construtor now takes two new  arguments, the template filename extension,
and the renderer.
</p>
<p>DefaultCollection now vastly simplifies our views if we 
   just want the default templates rendered:
</p>
<pre>
<span class="PreProc">from</span> robaccia.defaultcollection <span class="PreProc">import</span> DefaultCollection
<span class="PreProc">from</span> robaccia <span class="PreProc">import</span> render
<span class="Statement">class</span> <span class="Identifier">Collection</span>(DefaultCollection):
    <span class="Comment"># GET /{view}/</span>
<span class="Statement">def</span> <span class="Identifier">list</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># GET /{view}/{id}</span>
<span class="Statement">def</span> <span class="Identifier">retrieve</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># PUT /{view}/{id}</span>
<span class="Statement">def</span> <span class="Identifier">update</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># DELETE /{view}/{id}</span>
<span class="Statement">def</span> <span class="Identifier">delete</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># POST /{view}/</span>
<span class="Statement">def</span> <span class="Identifier">create</span>(self, environ, start_response):
        <span class="Statement">pass</span>
app = Collection(<span class="Normal">'</span><span class="Constant">html</span><span class="Normal">'</span>, render)
</pre>
<p>To stop handling a particular URI, such as deleting a member of the collection, 
just remove the associated member function. 
</p>
<h4>run</h4>
<p>We are almost done with our first scenario. All we need now is a 
way to run our application. Since we based Robaccia on WSGI we can use
<a href="http://docs.python.org/lib/module-wsgiref.html">wsgiref</a> to run our application under a local web server for development
purposes.
</p>
<h3><tt>robaccia-admin</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">run</span>(args):
    <span class="Normal">"""</span><span class="Constant">robaccia run           </span>
<span class="Constant">Start running the application under</span>
<span class="Constant">a local web server.</span>
<span class="Normal">"""</span>
<span class="PreProc">from</span> dispatcher <span class="PreProc">import</span> app
    <span class="PreProc">from</span> wsgiref.simple_server <span class="PreProc">import</span> WSGIServer, WSGIRequestHandler
    robaccia.init_logging()
    httpd = WSGIServer((<span class="Normal">''</span>, 3100), WSGIRequestHandler)
    httpd.set_app(app)
    <span class="Statement">print</span> <span class="Normal">"</span><span class="Constant">Serving HTTP on %s port %s ...</span><span class="Normal">"</span> % httpd.socket.getsockname()
    httpd.serve_forever()
</code></pre>
<p>Note again we know the WSGI app to load because of our file layout conventions.
The last piece of the puzzle is how dispatcher.py routes the incoming
requests to the right view.
</p>
<h3><tt>dispatcher.py</tt></h3>
<pre><code><span class="PreProc">from</span> robaccia.wsgidispatcher <span class="PreProc">import</span> Dispatcher
<span class="PreProc">from</span> robaccia <span class="PreProc">import</span> deferred_collection
app = Dispatcher()
app.add(<span class="Normal">'</span><span class="Constant">/{view:alnum}/[{id:unreserved}][;{noun:unreserved}]</span><span class="Normal">'</span>, deferred_collection)
</code></pre>
<p>A <tt>dispatcher.py</tt> is copied into every project so that you can customize it later
  if you want to do something besides the default everything-is-a-collection convention.
  Any URI templates added before the one that's already there will match first.
</p>
<p>It's <tt>deferred_collection</tt> that does our lookup of the view to call.</p>
<h3><tt>deferred_collection()</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">deferred_collection</span>(environ, start_response):
    <span class="Normal">"""</span><span class="Constant">Look for a views.* module to handle this incoming</span>
<span class="Constant">    request. Presumes the module has </span>
<span class="Constant">    an 'app' that is a WSGI application.</span><span class="Normal">"""</span>
<span class="Comment"># Pull out the view name from the template parameters</span>
    view = environ[<span class="Normal">'</span><span class="Constant">wsgiorg.routing_args</span><span class="Normal">'</span>][1][<span class="Normal">'</span><span class="Constant">view</span><span class="Normal">'</span>]
    <span class="Comment"># Load the named view from the 'views' directory</span>
    m = __import__(<span class="Normal">"</span><span class="Constant">views.</span><span class="Normal">"</span> + view, globals(), locals())
    <span class="Comment"># Pass along the WSGI call into the given application</span>
    logging.getLogger(<span class="Normal">'</span><span class="Constant">robaccia</span><span class="Normal">'</span>).debug(<span class="Normal">"</span><span class="Constant">View: %s</span><span class="Normal">"</span> % view)
    <span class="Statement">return</span> getattr(getattr(m, view), <span class="Normal">'</span><span class="Constant">app</span><span class="Normal">'</span>)(environ, start_response)
</code></pre>
<p>We construct the view name from the incoming path and then load
that module dynamically. Of course a little error handling, like returning 
a 404 if the module isn't found, would be good, but you get the idea.
</p>
<p>So that finishes it, our first phase is complete. If we include a couple
simple templates for 'list.html' and 'retrieve.html' then we can run
the second scenario with this code:</p>
<pre>
joe@joe-laptop:~$ <b>robaccia-admin createproject myproject</b>
joe@joe-laptop:~$ <b>cd myproject/</b>
<i>/home/joe/myproject</i>
joe@joe-laptop:~/myproject$ <b>robaccia-admin addview fred</b>
<i> created views/fred.py 
 created templates/fred/list.html 
 created templates/fred/retrieve.html </i>
joe@joe-laptop:~/myproject$ <b>robaccia-admin run</b>
<i>Serving HTTP on 0.0.0.0 port 3100 ...
localhost - - [24/May/2007 11:14:49] "GET /fred/ HTTP/1.1" 200 116</i>
</pre>
<p>Pointing our browser at <tt>http://localhost:3100/fred/</tt> gets us:</p>
<p><img alt="Web page: Hello World!" src="http://bitworking.org/images/2007/05/robaccia-fred-list.png" /></p>
<h3>Phase Two - Model</h3>
<p>Now let's get cracking on adding in the database.</p>
<p class="aside">If you know me, you know I'm not a huge fan of
  relational databases, I prefer my stores more scalable and 
  my columns sparse, but let's not talk about that now. 
  All of the next generation web frameworks rely on a relational 
  database and this section will show how to do just that.  
</p>
<p>The very first thing we are going to need is a 
  configuration file for the database, which we'll use
  <tt>dbconfig.py</tt> and throw that into the default project
  files so it is always present.
</p>
<p>On top of the files we added for 'addview'
we will add in a model, and some template code for adding and editing
collection members.
</p>
<p>DefaultModelCollection 
does everything that DefaultCollection does, but now we have a 'model'
to keep track of. Those dictionaries are going from the model
into templates. There is also a way to parse incoming request bodies.
</p>
<h3><tt>defaultmodelcollection.py</tt></h3>
<pre><code><span class="PreProc">from</span> wsgicollection <span class="PreProc">import</span> Collection
<span class="PreProc">import</span> os
<span class="PreProc">from</span> robaccia <span class="PreProc">import</span> http200, http405, http404, http303
<span class="Statement">class</span> <span class="Identifier">DefaultModelCollection</span>(Collection):
    <span class="Statement">def</span> <span class="Identifier">__init__</span>(self, ext, renderer, parser, model):
        Collection.__init__(self)
        self._ext = ext
        self._renderer = renderer <span class="Comment"># converts dicts to representations</span>
        self._model = model
        self._parser = parser     <span class="Comment"># converts representations to dicts</span>
        self._repr = {}           <span class="Comment"># request representation as a dict()</span>
<span class="Statement">def</span> <span class="Identifier">__call__</span>(self, environ, start_response):
        response = Collection.__call__(self, environ, start_response)
        <span class="Statement">if</span> environ[<span class="Normal">'</span><span class="Constant">REQUEST_METHOD</span><span class="Normal">'</span>] <span class="Statement">in</span> [<span class="Normal">'</span><span class="Constant">PUT</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">POST</span><span class="Normal">'</span>]:
            self._repr = self._parser(environ)
        <span class="Statement">if</span> response == None:
            primary = self._model.primary_key.columns.keys()[0]
            view = environ[<span class="Normal">'</span><span class="Constant">wsgiorg.routing_args</span><span class="Normal">'</span>][1].get(<span class="Normal">'</span><span class="Constant">view</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">.</span><span class="Normal">'</span>)
            template_file = os.path.join(view, self._function_name + <span class="Normal">"</span><span class="Constant">.</span><span class="Normal">"</span> + self._ext)
            method = environ.get(<span class="Normal">'</span><span class="Constant">REQUEST_METHOD</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">GET</span><span class="Normal">'</span>)
            <span class="Statement">if</span> self._id:
                <span class="Statement">if</span> method == <span class="Normal">"</span><span class="Constant">POST</span><span class="Normal">"</span> <span class="Statement">and</span> <span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span> <span class="Statement">in</span> 
                    self._repr <span class="Statement">and</span> self._repr[<span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span>] <span class="Statement">in</span> [<span class="Normal">"</span><span class="Constant">PUT</span><span class="Normal">"</span>, <span class="Normal">"</span><span class="Constant">DELETE</span><span class="Normal">"</span>]:
                    method = self._repr[<span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span>]
                    <span class="Statement">del</span> self._repr[<span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span>]
                <span class="Statement">if</span> method == <span class="Normal">'</span><span class="Constant">GET</span><span class="Normal">'</span>:
                    result = self._model.select(self._model.c[primary]==self._id
                       ).execute()
                    row = result.fetchone()
                    <span class="Statement">if</span> None == row:
                        <span class="Statement">return</span> http404(environ, start_response)
                    data = dict(zip(result.keys, row))
                    <span class="Statement">return</span> self._renderer(environ, start_response, template_file, 
                          {<span class="Normal">"</span><span class="Constant">row</span><span class="Normal">"</span>: data, <span class="Normal">"</span><span class="Constant">primary</span><span class="Normal">"</span>: primary})
                <span class="Statement">elif</span> method == <span class="Normal">'</span><span class="Constant">PUT</span><span class="Normal">'</span>:
                    self._model.update(self._model.c[primary]==self._id
                        ).execute(self._repr)
                    <span class="Statement">return</span> http303(environ, start_response, self._id)
                <span class="Statement">elif</span> method == <span class="Normal">'</span><span class="Constant">DELETE</span><span class="Normal">'</span>:
                    self._model.delete(self._model.c[primary]==self._id).execute()
                    <span class="Statement">return</span> http303(environ, start_response, <span class="Normal">"</span><span class="Constant">./</span><span class="Normal">"</span>)
                <span class="Statement">else</span>:
                    <span class="Statement">print</span> method
                    <span class="Statement">return</span> http405(environ, start_response)
            <span class="Statement">else</span>:
                <span class="Statement">if</span> method == <span class="Normal">'</span><span class="Constant">GET</span><span class="Normal">'</span>:
                    result = self._model.select().execute()
                    meta = self._model.columns.keys()
                    data = [dict(zip(result.keys, row)) <span class="Statement">for</span> row <span class="Statement">in</span> result.fetchall()]
                    <span class="Statement">return</span> self._renderer(environ, start_response, template_file, 
                       {<span class="Normal">"</span><span class="Constant">data</span><span class="Normal">"</span>: data, <span class="Normal">"</span><span class="Constant">primary</span><span class="Normal">"</span>: primary, <span class="Normal">"</span><span class="Constant">meta</span><span class="Normal">"</span>: meta})
                <span class="Statement">elif</span> method == <span class="Normal">'</span><span class="Constant">POST</span><span class="Normal">'</span>:
                    self._model.insert(self._repr).execute()
                    <span class="Statement">return</span> http303(environ, start_response, <span class="Normal">"</span><span class="Constant">.</span><span class="Normal">"</span>)
        <span class="Statement">else</span>:
            <span class="Statement">return</span> response
</code></pre>
<p>Note that the constructor takes a renderer, a parser, and a model.
   The renderer takes dictionaries and turns them into response bodies.
   The parser takes incoming request bodies and turns them 
   into dictionaries. We already have an HTML renderer, all we need to do
   form processing is something that takes incoming 'application/x-www-form-urlencoded'
   data and converts it into a dictionary, which is easy to come by.
</p>
<p>We need to update our 'view' to handle the 'edit' and 'new' forms, which
just means adding 'get_edit_form()' and 'get_new_form()' functions to the 
view. The templates are also pretty simple. Here is the updated
'list.html':</p>
<h3><tt>list.html</tt></h3>
<pre><code><span class="Identifier">&lt;</span><span class="Statement">html</span><span class="Identifier"> xmlns=</span><span class="Constant">"<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>"</span><span class="Identifier"> xmlns:py=</span><span class="Constant">"<a href="http://genshi.edgewall.org/">http://genshi.edgewall.org/</a>"</span><span class="Identifier">  &gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">head</span><span class="Identifier">&gt;</span>
<span class="PreProc"></span><span class="Identifier">&lt;</span><span class="Statement">title</span><span class="Identifier">&gt;</span><span class="Title">Fred</span><span class="Identifier">&lt;/</span><span class="Statement">title</span><span class="Identifier">&gt;</span><span class="PreProc"></span>
<span class="PreProc"></span><span class="Identifier">&lt;/</span><span class="Statement">head</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">body</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">p</span><span class="Identifier">&gt;&lt;</span><span class="Statement">a</span><span class="Identifier"></span><span class="Type">href</span><span class="Identifier">=</span><span class="Constant">";new_form"</span><span class="Identifier">&gt;</span><span class="Underlined">New</span><span class="Identifier">&lt;/</span><span class="Statement">a</span><span class="Identifier">&gt;&lt;/</span><span class="Statement">p</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">p</span><span class="Identifier"> py:</span><span class="Type">for</span><span class="Identifier">=</span><span class="Constant">"row in data"</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">p</span><span class="Identifier"> py:</span><span class="Type">for</span><span class="Identifier">=</span><span class="Constant">"key, value in row.iteritems()"</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">b</span><span class="Identifier">&gt;</span><span class="htmlBold">$key</span><span class="Identifier">&lt;/</span><span class="Statement">b</span><span class="Identifier">&gt;</span>: $value
            <span class="Identifier">&lt;/</span><span class="Statement">p</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">a</span><span class="Identifier"></span><span class="Type">href</span><span class="Identifier">=</span><span class="Constant">"${row[primary]}"</span><span class="Identifier">&gt;</span><span class="Underlined">${row[primary]}</span><span class="Identifier">&lt;/</span><span class="Statement">a</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">hr</span><span class="Identifier">/&gt;</span>
<span class="Identifier">&lt;/</span><span class="Statement">p</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;/</span><span class="Statement">body</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;/</span><span class="Statement">html</span><span class="Identifier">&gt;</span>
</code></pre>
<p>And now we're able to meet our initial design:</p>
<pre>
joe@joe-laptop:~$ <b>robaccia-admin createproject myprj</b>
joe@joe-laptop:~$ <b>cd myprj/</b>
<i>/home/joe/myprj</i>
joe@joe-laptop:~/myprj$ <b>robaccia-admin addmodelview employees</b>
<i> created views/employees.py 
 created models/employees.py 
 created templates/employees/list.html 
 created templates/employees/retrieve.html 
 created templates/employees/get_edit_form.html 
 created templates/employees/get_new_form.html </i>
joe@joe-laptop:~/myprj$ <b>vim models/employees.py</b>
joe@joe-laptop:~/myprj$ <b>cat models/employees.py</b>
<i>from sqlalchemy import Table, Column, Integer, String
import dbconfig
table = Table('employees', dbconfig.metadata,
        Column('id', Integer(), primary_key=True),
        Column('name', String(250)), 
        Column('title', String(250)),
        Column('office_number', Integer()),
        )
</i>
joe@joe-laptop:~/myprj$ <b>robaccia-admin createdb</b>
joe@joe-laptop:~/myprj$ <b>robaccia-admin run</b>
<i>Serving HTTP on 0.0.0.0 port 3100 ...</i>
</pre>
<p>The database is initially empty.  Click on New to create a new member in the collection.  </p>
<p><img alt="Web page: New" src="http://bitworking.org/images/2007/05/robaccia-employees-new.png" /></p>
<p>Creating a new employee.</p>
<p><img alt="Web page: Form for creating a new employee" src="http://bitworking.org/images/2007/05/robaccia-employees-new-form.png" /></p>
<p>Our collection list afer adding couple new employees. Note the link to individual employees.</p>
<p><img alt="Web page: List of two added employees" src="http://bitworking.org/images/2007/05/robaccia-employees-list.png" /></p>
<p>From an individual collection member we can edit and delete the employee.</p>
<p><img alt="Web page: A single employee" src="http://bitworking.org/images/2007/05/robaccia-employees-retrieve.png" /></p>
<p>A form for editing the employee.</p>
<p><img alt="Web page: Editing a single employee" src="http://bitworking.org/images/2007/05/robaccia-employees-edit-form.png" /></p>
<h3>Lessons</h3>
<p>We came up with a rather simple database to web framework, but in reality
 haven't lost any flexibility over the original Robaccia. All the pieces 
 of URI dispatching, views and templates are present, all we did
 was pave the happy path.
</p>
<p>We paved the happy path by embracing the following constraints:</p>
<p><ol>
<li>All resource fit into a collection.</li>
<li>A single URI path structure.</li>
<li>A fixed model interface: SQLAlchemy.</li>
<li>A fixed project layout.</li>
<li>WSGI as method of communication between components.</li>
<li>A single media-type for any single view. (You can
        have different views with different media-types that
        use the same model.) 
    </li>
<li>Not really mentioned explicitly, but all the configuration
        was done through Python files.</li>
</ol></p>
<h3>Observations</h3>
<p>The code so far has renderers and parsers for HTML and
HTML forms, but we could easily add support for JSON or Atom.
</p>
<p>There isn't much that ties us to SQLAlchemy; just DefaultModelDispatcher
and the initial files put down by 'robaccia addmodelview'. We could easily 
switch out to another ORM, or even drop the RDBMS and move to another
kind of data store.
</p>
<p>There is a whole slew of stuff that hasn't been done like 
   handling changes to the database, deployment, security,  
   large collections that require paging, etc. Those are all solvable
   problems, and not the point of this exercise, which was to 
   demonstrate applying constraints to reduce cognitive and manual 
  load to create a Rails/Django-like web framework. 
</p>
<p>The code is now available on <a href="http://code.google.com/p/robaccia/">code.google.com</a>.
If you run it under Python 2.5 you will only need to install SQLAlchemy and Genshi. 
For Python 2.4 you will also need to install wsgiref.
</p>
  <div class="commentContent" id="X1">
    I'm not quite to the point in my projects where I can leverage WSGI directly, so I've done something very similar within TurboGears.  Take a look:
http://www.graffitiweb.org/blog/2007/05/25/restresource-03-crud-for-turbogears/
or directly to the code at:
http://microapps.googlecode.com/svn/restresource/tags/0.3/

">
  
  <meta name="twitter:card"  content="summary">
  <meta name="twitter:image" content="https://bitworking.org/images/newlogo.png">
  
  
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1974123-1', 'auto');
  ga('send', 'pageview');

</script>
  

  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">BitWorking</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Gloves</h1>
    <p class="post-meta">
      <a class="u-url" href="/news/2007/05/Gloves">
        <time datetime="2007-05-24T00:00:00-04:00" itemprop="datePublished" class="dt-published">
          
          May 24, 2007
        </time>
      </a>
      â€¢ <a rel="author" class="p-author h-card" href="/about"> <span itemprop="author"
          itemscope itemtype="http://schema.org/Person">
          <img class="u-photo" src="/images/joe2016.jpg" alt="" style="height: 16px; border-radius: 8px; margin-right: 4px;" />
          <span
            itemprop="name">Joe Gregorio</span></span></a>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
      <p>
Last time I talked about the creation of <a href="http://bitworking.org/news/Why_so_many_Python_web_frameworks">Robaccia</a>
I got to the point of a working framework and just waved
my hands and said you could keep going and "just" add conventions. 
I have pointed out that <a href="http://fishbowl.pastiche.org/2003/10/07/just_is_a_fourletter_word">"just" is a dangerous word</a>, 
so let's walk through the rest of the steps
to building a Rails/Django-like web framework.
</p>
<p><b>Update:</b> Just so there's no confusion, the title of this post comes from 
<a href="http://worsethanfailure.com/Articles/The_Complicator_0x27_s_Gloves.aspx">The Complicator's Gloves</a>.</p>
  <p>They key point of adding 'conventions'  is to take 
   a load off the user. You need to actually remove two kinds
   of load, cognitive and manual. Cognitive load is the number
   of concepts you need to hold in your head. The fewer the number of 
   concepts, and the more uniformly they are applied, the easier the
   system will be to use. Manual load is just the amount of 
   manual stuff, like typing, that you need to do. Why should
   I have to manually create a directory structure when a computer
   is capable of doing that? 
</p>
<h3>Motivation</h3>
<p class="aside">Before diving into lots of code and details
  let's clarify what I'm trying to accomplish here. I am <b>not</b>
  trying to write Rails for Python. My mission in creating this 
  software, and this write-up, is to lay out the core ideas 
  of constraints, cognitive load, and manual load, and how to apply 
  them to create a Rails/Django-like web framework, in the hopes 
  that it is helpful, so that <i>you</i> can 
  use it to create your own Rails-like framework in your language
  of choice.
</p>
<p class="aside">In this example I make some design decisions that
might seem a bit extreme. They are. You probably should make 
different choices for your web framework based on your programming
language and problem domain.
</p>
<h3>The Happy Path</h3>
<p>I am going to borrow a term from testing, <a href="http://en.wikipedia.org/wiki/Happy_path">Happy Path</a>,
   and use it in the context of creating our conventions. We need to pick
   a happy path when using our framework, and we need to knock down as many
   barriers, and make things as easy as possible, as long as users stick
   to that happy path.
</p>
<h3>Design</h3>
<p>If you are familiar with Ruby on Rails or Django then
the development story should be familiar. Here's the 
core of our design document. Creating an employee
application should consist of the following steps:</p>
<pre>
    $ robaccia createproject myproject 
    $ cd myproject 
    $ robaccia addmodelview employees <i># Creates  view, templates, and model.</i>
    $ gvim ./models/employees.py      <i># Add table columns.</i>
    $ robaccia createdb
    $ robaccia run
    $ firefox http://localhost:8080/employees/
</pre>
<p>
Of course, we may already have a model in place, and want
to just create another view on that model. Adding a view-only collection
should be as simple as:
</p>
<pre>
    $ robaccia addview employees
    $ robaccia run
    $ firefox http://localhost:8080/employees/
</pre>
<h3>Preliminaries</h3>
<p>
Currently Robaccia consists of a couple modules and a 
bunch of conventions for how to lay out a project.
They include the files: 
</p>
<ul>
<li><code>model.py</code> - One or more models expressed in SQLAlchemy Tables.</li>
<li><code>view.py</code> - One or more views, implemented as WSGI applications.</li>
<li><code>urls.py</code> - A single instance of a selector object that maps URIs to the WSGI applications in <code>view.py</code>.</li>
<li><code>templates</code> - A directory of Kid templates to be used to format the responses from the view applications.</li>
<li><code>dbconfig.py</code> - Configuration for the SQLAlchemy Tables in model.py</li>
</ul>
<p>
To accomodate making more complex projects we'll update most of those
files to be directories, and add another directory for log files:
</p>
<pre>
    /views
    /templates
    /models
    /logs
</pre>
<p>We'll leave <code>urls.py</code> as a file, but just rename it 
to <code>dispacher.py</code>, because while it does match
based on the incoming URI, it also matches on the request method,
so let's name it for what it does.</p>
<p>So let's look at what the directory structure we
 have for a Robaccia based application:
 </p>
<pre>
views/
models/
templates/
logs/
dispatcher.py
</pre>
<p>And if we add a new resource to our application we distribute
 the model, view, and template files under each of those directories.
 </p>
<pre>
views/<b>name</b>.py
models/<b>name</b>.py
templates/<b>name</b>/list.html
templates/<b>name</b>/retrieve.html
...
logs/
</pre>
<p>
  Now Robaccia, using selector, allows you to dispatch to any
  view from any form of URI and any method. We need to simplify
  that, by adding constraints, and guide those constraints
  using a conceptual model. You can't possibly be surprised
  that I would choose a RESTful collection as an organizing principle.
  In particular, we'll assume that everything you want to create
  will fit into <a href="http://bitworking.org/news/wsgicollection">wsgicollection</a>.
  We will, obviously, build in an escape hatch, but RESTful
  collections will be our happy path.
</p>
<p>
  In general, using the notation of selector, we are looking at URIs 
  of the form:
  </p>
<pre><code> /...people/[{id}][;{noun}] </code></pre>
<p>
  And dispatching requests to URIs of that form to functions with nice names:
  </p>
<pre><code>  GET    /people               list()
  POST   /people               create()
  GET    /people/1             retrieve()
  PUT    /people/1             update()
  DELETE /people/1             delete()
  GET    /people;create_form   get_create_form()
  GET    /people/1;edit_form   get_edit_form()
  </code></pre>
<p>
We'll wrap all those target functions up into a single class and make
instances of those classes a WSGI application:
</p>
<pre><code><span class="PreProc">from</span> wsgicollection <span class="PreProc">import</span> Collection
<span class="Statement">class</span> <span class="Identifier">People</span>(Collection):
    <span class="Comment"># GET /people/</span>
<span class="Statement">def</span> <span class="Identifier">list</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># POST /people/</span>
<span class="Statement">def</span> <span class="Identifier">create</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># GET /people/1</span>
<span class="Statement">def</span> <span class="Identifier">retrieve</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># PUT /people/1</span>
<span class="Statement">def</span> <span class="Identifier">update</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># DELETE /people/1</span>
<span class="Statement">def</span> <span class="Identifier">delete</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># GET /people/;create_form</span>
<span class="Statement">def</span> <span class="Identifier">get_create_form</span>(environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># POST /people/1;comment_form</span>
<span class="Statement">def</span> <span class="Identifier">post_comment_form</span>(environ, start_response):
        <span class="Statement">pass</span>
</code></pre>
<p>So if a collection is our organizing principle, what about our URI structure?
Let's keep it simple and presume everything will fall into a simple
URI template:
</p>
<pre><code>
/{view:alnum}/[{id:unreserved}][;{noun:unreserved}]
</code></pre>
<p>That is, each {view} represents a collection, and {view}/{id} is a member
of that collection. That's very simple and we have introduced a number of 
constraints by restricting ourselves to this URI structure:
</p>
<dl>
<dt>Content type</dt>
<dd>We presume that this collection has a single content type, such
       as HTML, or JSON. There is no provision for having a single collection
       serve up content in different media types. If you want to handle different
       media types then you can create two views that reference the same
       underlying model.
    </dd>
<dt>Nesting</dt>
<dd>The namespace is very flat, not allowing nesting of 
    resources beyond the simple collection. For example, if you were
    creating blogging application, you couldn't create 
    the main blog as a collection of entries, <code>/blog/{id}</code>,
    and then have a collection of comments for each blog entry, ala
    <code>/blog/{id}/comments/{commentid}</code>, but you could 
    have a collection that worked on all comments received, 
    <code>/comments/{id}</code>. Again, you can certainly
    do the nested collections for comments with the tools we are 
    going to supply, but that is not on the happy path. 
    </dd>
</dl>
<p>
  Also, in the intervening time since Robaccia was initially released
  I've written my own version of selector, 
  <a href="http://bitworking.org/news/163/WSGIDispatcher">wsgidispatcher</a>,
  so we'll switch to using that. The activity around Kid has diminished
  and moved mostly to Genshi, so we will also migrate to Genshi for templating.
</p>
<p>
    RESTful collections, and a highly constrained URI scheme, are the concepts
    we're using to reduce cognitive load.
    On the manual load side, we'll build some command line tools
    to automate the generation of stubs and directories.
</p>
<h3>Implementation</h3>
<p>
To fulfill our design we'll take the current Robaccia through a number
of incremental steps. The first step is modularization.
</p>
<h4>Modularize robaccia</h4>
<p>
We need to convert Robaccia from a set of conventions and 
a few lines of code into a library on it's own. First, we consolidate
all the code into a single installable module. We'll also create a stub
for the 'robaccia-admin' program, the one we'll eventually use to create 
the skeleton for project. 
</p>
<pre> 
   robaccia.py =&gt; robaccia/__init__.py # controversial in some quarters
   wsgidispatcher.py =&gt; robaccia/wsgidispatcher.py
   wsgicollection.py =&gt; robaccia/wsgicollection.py
   mimetypes.py =&gt; robaccia/mimetypes.py
</pre>
<p>
The only change that this requires in our code is a change in the imports
for wsgicollection and wsgidispatcher.
</p>
<p>
Now let's create a <code>setup.py</code> so our new module can be installed.
This uses the built-in <a href="http://docs.python.org/lib/module-distutils.html">distutils</a> library, and the configuration
  file is really a Python program.
</p>
<pre>
[<a href="http://robaccia.googlecode.com/svn/trunk/setup.py">setup.py</a>]
</pre>
<p>
Note that this setup file not only installs the robaccia library, but 
also the 'robaccia-admin' program.
</p>
<h4>robaccia-admin</h4>
<p>
We want to create a program that we can run that takes 
commands as arguments, just like 'svn' or 'bzr'. In addition we
want help, and also, like 'bzr', a way to make the
command set extensible. At the very least, we want to make
adding new command to 'robaccia-admin' easy. The simplest thing
that could possibly work is to have the command name 
match a method name in the module, and just look them up 
on the fly. 
</p>
<h3><tt>robaccia-bin</tt></h3>
<pre><code>members = globals()
<span class="Statement">if</span> __name__ == "<span class="Constant">__main__</span>":
    <span class="Statement">try</span>:
        cmd = sys.argv[1]
    <span class="Statement">except</span>:
        cmd = "<span class="Constant">help</span>"
    args = sys.argv[2:]
    <span class="Statement">if</span> cmd <span class="Statement">not</span> <span class="Statement">in</span> members <span class="Statement">or</span>  
             cmd.startswith("<span class="Constant">_</span>") <span class="Statement">or</span> (<span class="Statement">not</span> callable(members[cmd])):
        cmd = "<span class="Constant">help</span>"
    members[cmd](args)
</code></pre>
<p>
Note that if a command isn't found in 'members', then
we assume the command "help". That gets us running commands, but
how do we do help? We need two kinds of help, a short message 
on how to use a command, used when we request a list of commands, and
a longer help description for when we want help on a single command.
Also, I don't want to write a separate help file.
</p>
<p>In Python if the first thing in your method is a string, then that
string is available via the __doc__ attribute. We'll put in place
a convention that the first line of the doc string is a short
description, and the whole doc string will be used for help
on that command. So, as an example, here is the implementation
for the 'commands' command. Run 'robaccia-admin commands' to get a list
of all the commands that the robaccia program supports. 
</p>
<h3><tt>robaccia-bin</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">commands</span>(args):
    """<span class="Constant">robaccia commands     </span>
<span class="Constant"></span>
<span class="Constant">List all known commands that robaccia knows.</span>
"""
    <span class="Statement">for</span> name <span class="Statement">in</span> members:
        <span class="Statement">if</span> <span class="Statement">not</span> name.startswith("<span class="Constant">_</span>") <span class="Statement">and</span> callable(members[name]):
            <span class="Statement">print</span> members[name].__doc__.splitlines()[0]
</code></pre>
<p>
So now we can add the 'createproject' command. The 'createproject' command just
creates a directory structure populated with some default files. Looking back
into 'setup.py' you can see the 'package_data' parameter, which is a list
of non-source files that can be packaged with the library. 
We will stuff a skeleton project directory structure in there
and copy it over when we create a project.  We'll leverage Python's 
ability to introspect here, as each module has
a __file__ attribute which is the location of the source file, and 
we will use that to construct a path to the template files.
</p>
<h3><tt>robaccia-bin</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">createproject</span>(args):
    <span class="Normal">"""</span><span class="Constant">robaccia createproject &lt;name&gt;   </span>
<span class="Constant">Creates a new project directory structure.</span>
<span class="Constant">The target directory must not exist.</span>
<span class="Constant"></span><span class="Normal">"""</span>
<span class="Statement">try</span>:
        name = args[0]
    <span class="Statement">except</span>:
        sys.exit(<span class="Normal">"</span><span class="Constant">Error: Missing required parameter &lt;name&gt;.</span><span class="Normal">"</span>)
    <span class="Statement">if</span> os.path.exists(name):
        sys.exit(<span class="Normal">"</span><span class="Constant">Error: Directory '%s' already exists</span><span class="Normal">"</span> % name)
    template_dir = os.path.abspath(
       os.path.join(robaccia.__file__, <span class="Normal">"</span><span class="Constant">..</span><span class="Normal">"</span>, <span class="Normal">"</span><span class="Constant">templates</span><span class="Normal">"</span>, <span class="Normal">"</span><span class="Constant">project</span><span class="Normal">"</span>)
    )
    shutil.copytree(template_dir, name)
</code></pre>
<h4>addview</h4>
<p>At this point let's skip to our second scenario and
  implement the 'addview' command. We'll go back later and 
  add the 'addmodelview' command.
</p>
<p>We'd like to keep the cognitive load as small as possible. 
If you look at the original implementation of Robaccia, each 
view had to render it's own template:</p>
<p><b>!! This is the old way, what were trying to replace  !!</b></p>
<pre><code>
<span class="PreProc">import</span> selector
<span class="PreProc">import</span> view
urls = selector.Selector()
urls.add(<span class="Normal">'</span><span class="Constant">/blog/</span><span class="Normal">'</span>, GET=view.list)
urls.add(<span class="Normal">'</span><span class="Constant">/blog/{id}/</span><span class="Normal">'</span>, GET=view.member_get)
</code></pre>
<p><b>!! This is the old way, what were trying to replace  !!</b></p>
<pre><code>
<span class="Statement">def</span> <span class="Identifier">list</span>(environ, start_response):
    rows = model.entry_table.select().execute()
    <span class="Statement">return</span> robaccia.render(start_response, <span class="Normal">'</span><span class="Constant">list.html</span><span class="Normal">'</span>, locals())
</code></pre>
<p>WSGICollection helps by adding an idiom and removing the need
to map each request URI and method to a WSGI application, but we 
can do better. We can take <code>robaccia.render()</code>
and presume that every renderer will conform to that signature. 
Since we have a convention for how files will be laid out, we can
do even more work, we can look up the template to render using
the name of the WSGICollection that was called, and the name of the 
member function that was called.
The only piece of information we are missing is the file extension
of the template, so we will have to pass that in also.
</p>
<p>What we want, for example, is that if we add a collection 'fred':
<pre>
   /views/<b>fred</b>.py
   /templates/<b>fred</b>/list.html
   /templates/<b>fred</b>/retreive.html
</pre>
</p><p>
Then a GET to <tt>/fred/</tt> will 
end up calling <code>views.fred.app.list()</code>, and the template
<tt>/templates/<b>fred</b>/list.html</tt> will be rendered.
</p>
<p>That's fine default behavior, but we need a way to signal whether we want
the default rendering to occur, of the collection view member function
has decided to over-ride the default behavior and do it's own processing.
</p>
<p>In normal processing a wsgicollection member function
returns an iterable. We can look for things besides 
iterables to indicate that we should look for a template and render it.
The simplest thing is to look for a dictionary, since that is what you
pass into a template to get rendered. We can also accept 'None'
in the response and convert that into some sort of acceptable dictionary to be
passed into the templating engine.
</p>
<p>Here is the implementation for DefaultCollection, which implements the above design:
</p>
<h3><tt>defaultcollection.py</tt></h3>
<pre><code><span class="PreProc">from</span> wsgicollection <span class="PreProc">import</span> Collection
<span class="PreProc">import</span> os
<span class="Statement">class</span> <span class="Identifier">DefaultCollection</span>(Collection):
    <span class="Statement">def</span> <span class="Identifier">__init__</span>(self, ext, renderer):
        Collection.__init__(self)
        self._ext = ext
        self._renderer = renderer
    <span class="Statement">def</span> <span class="Identifier">__call__</span>(self, environ, start_response):
        response = Collection.__call__(self, environ, start_response)
        <span class="Statement">if</span> response == None:
            <span class="Statement">if</span> self._id:
                response = {<span class="Normal">'</span><span class="Constant">id</span><span class="Normal">'</span>: self._id}
            <span class="Statement">else</span>:
                response = {}
        <span class="Statement">if</span> isinstance(response, dict):
            view = environ[<span class="Normal">'</span><span class="Constant">wsgiorg.routing_args</span><span class="Normal">'</span>][1].get(<span class="Normal">'</span><span class="Constant">view</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">.</span><span class="Normal">'</span>)
            template_file = os.path.join(view, self._function_name + <span class="Normal">"</span><span class="Constant">.</span><span class="Normal">"</span> + self._ext)
            <span class="Statement">return</span> self._renderer(environ, start_response, template_file, response)
        <span class="Statement">else</span>:
            <span class="Statement">return</span> response
</code></pre>
<p>Note that we hand off most of the work to wsgicollection.Collection, and
then if the response is a dictionary we look up the template 
and pass the name into the renderer. The only other thing to note is that
the construtor now takes two new  arguments, the template filename extension,
and the renderer.
</p>
<p>DefaultCollection now vastly simplifies our views if we 
   just want the default templates rendered:
</p>
<pre>
<span class="PreProc">from</span> robaccia.defaultcollection <span class="PreProc">import</span> DefaultCollection
<span class="PreProc">from</span> robaccia <span class="PreProc">import</span> render
<span class="Statement">class</span> <span class="Identifier">Collection</span>(DefaultCollection):
    <span class="Comment"># GET /{view}/</span>
<span class="Statement">def</span> <span class="Identifier">list</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># GET /{view}/{id}</span>
<span class="Statement">def</span> <span class="Identifier">retrieve</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># PUT /{view}/{id}</span>
<span class="Statement">def</span> <span class="Identifier">update</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># DELETE /{view}/{id}</span>
<span class="Statement">def</span> <span class="Identifier">delete</span>(self, environ, start_response):
        <span class="Statement">pass</span>
<span class="Comment"># POST /{view}/</span>
<span class="Statement">def</span> <span class="Identifier">create</span>(self, environ, start_response):
        <span class="Statement">pass</span>
app = Collection(<span class="Normal">'</span><span class="Constant">html</span><span class="Normal">'</span>, render)
</pre>
<p>To stop handling a particular URI, such as deleting a member of the collection, 
just remove the associated member function. 
</p>
<h4>run</h4>
<p>We are almost done with our first scenario. All we need now is a 
way to run our application. Since we based Robaccia on WSGI we can use
<a href="http://docs.python.org/lib/module-wsgiref.html">wsgiref</a> to run our application under a local web server for development
purposes.
</p>
<h3><tt>robaccia-admin</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">run</span>(args):
    <span class="Normal">"""</span><span class="Constant">robaccia run           </span>
<span class="Constant">Start running the application under</span>
<span class="Constant">a local web server.</span>
<span class="Normal">"""</span>
<span class="PreProc">from</span> dispatcher <span class="PreProc">import</span> app
    <span class="PreProc">from</span> wsgiref.simple_server <span class="PreProc">import</span> WSGIServer, WSGIRequestHandler
    robaccia.init_logging()
    httpd = WSGIServer((<span class="Normal">''</span>, 3100), WSGIRequestHandler)
    httpd.set_app(app)
    <span class="Statement">print</span> <span class="Normal">"</span><span class="Constant">Serving HTTP on %s port %s ...</span><span class="Normal">"</span> % httpd.socket.getsockname()
    httpd.serve_forever()
</code></pre>
<p>Note again we know the WSGI app to load because of our file layout conventions.
The last piece of the puzzle is how dispatcher.py routes the incoming
requests to the right view.
</p>
<h3><tt>dispatcher.py</tt></h3>
<pre><code><span class="PreProc">from</span> robaccia.wsgidispatcher <span class="PreProc">import</span> Dispatcher
<span class="PreProc">from</span> robaccia <span class="PreProc">import</span> deferred_collection
app = Dispatcher()
app.add(<span class="Normal">'</span><span class="Constant">/{view:alnum}/[{id:unreserved}][;{noun:unreserved}]</span><span class="Normal">'</span>, deferred_collection)
</code></pre>
<p>A <tt>dispatcher.py</tt> is copied into every project so that you can customize it later
  if you want to do something besides the default everything-is-a-collection convention.
  Any URI templates added before the one that's already there will match first.
</p>
<p>It's <tt>deferred_collection</tt> that does our lookup of the view to call.</p>
<h3><tt>deferred_collection()</tt></h3>
<pre><code><span class="Statement">def</span> <span class="Identifier">deferred_collection</span>(environ, start_response):
    <span class="Normal">"""</span><span class="Constant">Look for a views.* module to handle this incoming</span>
<span class="Constant">    request. Presumes the module has </span>
<span class="Constant">    an 'app' that is a WSGI application.</span><span class="Normal">"""</span>
<span class="Comment"># Pull out the view name from the template parameters</span>
    view = environ[<span class="Normal">'</span><span class="Constant">wsgiorg.routing_args</span><span class="Normal">'</span>][1][<span class="Normal">'</span><span class="Constant">view</span><span class="Normal">'</span>]
    <span class="Comment"># Load the named view from the 'views' directory</span>
    m = __import__(<span class="Normal">"</span><span class="Constant">views.</span><span class="Normal">"</span> + view, globals(), locals())
    <span class="Comment"># Pass along the WSGI call into the given application</span>
    logging.getLogger(<span class="Normal">'</span><span class="Constant">robaccia</span><span class="Normal">'</span>).debug(<span class="Normal">"</span><span class="Constant">View: %s</span><span class="Normal">"</span> % view)
    <span class="Statement">return</span> getattr(getattr(m, view), <span class="Normal">'</span><span class="Constant">app</span><span class="Normal">'</span>)(environ, start_response)
</code></pre>
<p>We construct the view name from the incoming path and then load
that module dynamically. Of course a little error handling, like returning 
a 404 if the module isn't found, would be good, but you get the idea.
</p>
<p>So that finishes it, our first phase is complete. If we include a couple
simple templates for 'list.html' and 'retrieve.html' then we can run
the second scenario with this code:</p>
<pre>
joe@joe-laptop:~$ <b>robaccia-admin createproject myproject</b>
joe@joe-laptop:~$ <b>cd myproject/</b>
<i>/home/joe/myproject</i>
joe@joe-laptop:~/myproject$ <b>robaccia-admin addview fred</b>
<i> created views/fred.py 
 created templates/fred/list.html 
 created templates/fred/retrieve.html </i>
joe@joe-laptop:~/myproject$ <b>robaccia-admin run</b>
<i>Serving HTTP on 0.0.0.0 port 3100 ...
localhost - - [24/May/2007 11:14:49] "GET /fred/ HTTP/1.1" 200 116</i>
</pre>
<p>Pointing our browser at <tt>http://localhost:3100/fred/</tt> gets us:</p>
<p><img alt="Web page: Hello World!" src="http://bitworking.org/images/2007/05/robaccia-fred-list.png" /></p>
<h3>Phase Two - Model</h3>
<p>Now let's get cracking on adding in the database.</p>
<p class="aside">If you know me, you know I'm not a huge fan of
  relational databases, I prefer my stores more scalable and 
  my columns sparse, but let's not talk about that now. 
  All of the next generation web frameworks rely on a relational 
  database and this section will show how to do just that.  
</p>
<p>The very first thing we are going to need is a 
  configuration file for the database, which we'll use
  <tt>dbconfig.py</tt> and throw that into the default project
  files so it is always present.
</p>
<p>On top of the files we added for 'addview'
we will add in a model, and some template code for adding and editing
collection members.
</p>
<p>DefaultModelCollection 
does everything that DefaultCollection does, but now we have a 'model'
to keep track of. Those dictionaries are going from the model
into templates. There is also a way to parse incoming request bodies.
</p>
<h3><tt>defaultmodelcollection.py</tt></h3>
<pre><code><span class="PreProc">from</span> wsgicollection <span class="PreProc">import</span> Collection
<span class="PreProc">import</span> os
<span class="PreProc">from</span> robaccia <span class="PreProc">import</span> http200, http405, http404, http303
<span class="Statement">class</span> <span class="Identifier">DefaultModelCollection</span>(Collection):
    <span class="Statement">def</span> <span class="Identifier">__init__</span>(self, ext, renderer, parser, model):
        Collection.__init__(self)
        self._ext = ext
        self._renderer = renderer <span class="Comment"># converts dicts to representations</span>
        self._model = model
        self._parser = parser     <span class="Comment"># converts representations to dicts</span>
        self._repr = {}           <span class="Comment"># request representation as a dict()</span>
<span class="Statement">def</span> <span class="Identifier">__call__</span>(self, environ, start_response):
        response = Collection.__call__(self, environ, start_response)
        <span class="Statement">if</span> environ[<span class="Normal">'</span><span class="Constant">REQUEST_METHOD</span><span class="Normal">'</span>] <span class="Statement">in</span> [<span class="Normal">'</span><span class="Constant">PUT</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">POST</span><span class="Normal">'</span>]:
            self._repr = self._parser(environ)
        <span class="Statement">if</span> response == None:
            primary = self._model.primary_key.columns.keys()[0]
            view = environ[<span class="Normal">'</span><span class="Constant">wsgiorg.routing_args</span><span class="Normal">'</span>][1].get(<span class="Normal">'</span><span class="Constant">view</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">.</span><span class="Normal">'</span>)
            template_file = os.path.join(view, self._function_name + <span class="Normal">"</span><span class="Constant">.</span><span class="Normal">"</span> + self._ext)
            method = environ.get(<span class="Normal">'</span><span class="Constant">REQUEST_METHOD</span><span class="Normal">'</span>, <span class="Normal">'</span><span class="Constant">GET</span><span class="Normal">'</span>)
            <span class="Statement">if</span> self._id:
                <span class="Statement">if</span> method == <span class="Normal">"</span><span class="Constant">POST</span><span class="Normal">"</span> <span class="Statement">and</span> <span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span> <span class="Statement">in</span> 
                    self._repr <span class="Statement">and</span> self._repr[<span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span>] <span class="Statement">in</span> [<span class="Normal">"</span><span class="Constant">PUT</span><span class="Normal">"</span>, <span class="Normal">"</span><span class="Constant">DELETE</span><span class="Normal">"</span>]:
                    method = self._repr[<span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span>]
                    <span class="Statement">del</span> self._repr[<span class="Normal">"</span><span class="Constant">_method</span><span class="Normal">"</span>]
                <span class="Statement">if</span> method == <span class="Normal">'</span><span class="Constant">GET</span><span class="Normal">'</span>:
                    result = self._model.select(self._model.c[primary]==self._id
                       ).execute()
                    row = result.fetchone()
                    <span class="Statement">if</span> None == row:
                        <span class="Statement">return</span> http404(environ, start_response)
                    data = dict(zip(result.keys, row))
                    <span class="Statement">return</span> self._renderer(environ, start_response, template_file, 
                          {<span class="Normal">"</span><span class="Constant">row</span><span class="Normal">"</span>: data, <span class="Normal">"</span><span class="Constant">primary</span><span class="Normal">"</span>: primary})
                <span class="Statement">elif</span> method == <span class="Normal">'</span><span class="Constant">PUT</span><span class="Normal">'</span>:
                    self._model.update(self._model.c[primary]==self._id
                        ).execute(self._repr)
                    <span class="Statement">return</span> http303(environ, start_response, self._id)
                <span class="Statement">elif</span> method == <span class="Normal">'</span><span class="Constant">DELETE</span><span class="Normal">'</span>:
                    self._model.delete(self._model.c[primary]==self._id).execute()
                    <span class="Statement">return</span> http303(environ, start_response, <span class="Normal">"</span><span class="Constant">./</span><span class="Normal">"</span>)
                <span class="Statement">else</span>:
                    <span class="Statement">print</span> method
                    <span class="Statement">return</span> http405(environ, start_response)
            <span class="Statement">else</span>:
                <span class="Statement">if</span> method == <span class="Normal">'</span><span class="Constant">GET</span><span class="Normal">'</span>:
                    result = self._model.select().execute()
                    meta = self._model.columns.keys()
                    data = [dict(zip(result.keys, row)) <span class="Statement">for</span> row <span class="Statement">in</span> result.fetchall()]
                    <span class="Statement">return</span> self._renderer(environ, start_response, template_file, 
                       {<span class="Normal">"</span><span class="Constant">data</span><span class="Normal">"</span>: data, <span class="Normal">"</span><span class="Constant">primary</span><span class="Normal">"</span>: primary, <span class="Normal">"</span><span class="Constant">meta</span><span class="Normal">"</span>: meta})
                <span class="Statement">elif</span> method == <span class="Normal">'</span><span class="Constant">POST</span><span class="Normal">'</span>:
                    self._model.insert(self._repr).execute()
                    <span class="Statement">return</span> http303(environ, start_response, <span class="Normal">"</span><span class="Constant">.</span><span class="Normal">"</span>)
        <span class="Statement">else</span>:
            <span class="Statement">return</span> response
</code></pre>
<p>Note that the constructor takes a renderer, a parser, and a model.
   The renderer takes dictionaries and turns them into response bodies.
   The parser takes incoming request bodies and turns them 
   into dictionaries. We already have an HTML renderer, all we need to do
   form processing is something that takes incoming 'application/x-www-form-urlencoded'
   data and converts it into a dictionary, which is easy to come by.
</p>
<p>We need to update our 'view' to handle the 'edit' and 'new' forms, which
just means adding 'get_edit_form()' and 'get_new_form()' functions to the 
view. The templates are also pretty simple. Here is the updated
'list.html':</p>
<h3><tt>list.html</tt></h3>
<pre><code><span class="Identifier">&lt;</span><span class="Statement">html</span><span class="Identifier"> xmlns=</span><span class="Constant">"<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>"</span><span class="Identifier"> xmlns:py=</span><span class="Constant">"<a href="http://genshi.edgewall.org/">http://genshi.edgewall.org/</a>"</span><span class="Identifier">  &gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">head</span><span class="Identifier">&gt;</span>
<span class="PreProc"></span><span class="Identifier">&lt;</span><span class="Statement">title</span><span class="Identifier">&gt;</span><span class="Title">Fred</span><span class="Identifier">&lt;/</span><span class="Statement">title</span><span class="Identifier">&gt;</span><span class="PreProc"></span>
<span class="PreProc"></span><span class="Identifier">&lt;/</span><span class="Statement">head</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">body</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">p</span><span class="Identifier">&gt;&lt;</span><span class="Statement">a</span><span class="Identifier"></span><span class="Type">href</span><span class="Identifier">=</span><span class="Constant">";new_form"</span><span class="Identifier">&gt;</span><span class="Underlined">New</span><span class="Identifier">&lt;/</span><span class="Statement">a</span><span class="Identifier">&gt;&lt;/</span><span class="Statement">p</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">p</span><span class="Identifier"> py:</span><span class="Type">for</span><span class="Identifier">=</span><span class="Constant">"row in data"</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">p</span><span class="Identifier"> py:</span><span class="Type">for</span><span class="Identifier">=</span><span class="Constant">"key, value in row.iteritems()"</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">b</span><span class="Identifier">&gt;</span><span class="htmlBold">$key</span><span class="Identifier">&lt;/</span><span class="Statement">b</span><span class="Identifier">&gt;</span>: $value
            <span class="Identifier">&lt;/</span><span class="Statement">p</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">a</span><span class="Identifier"></span><span class="Type">href</span><span class="Identifier">=</span><span class="Constant">"${row[primary]}"</span><span class="Identifier">&gt;</span><span class="Underlined">${row[primary]}</span><span class="Identifier">&lt;/</span><span class="Statement">a</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;</span><span class="Statement">hr</span><span class="Identifier">/&gt;</span>
<span class="Identifier">&lt;/</span><span class="Statement">p</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;/</span><span class="Statement">body</span><span class="Identifier">&gt;</span>
<span class="Identifier">&lt;/</span><span class="Statement">html</span><span class="Identifier">&gt;</span>
</code></pre>
<p>And now we're able to meet our initial design:</p>
<pre>
joe@joe-laptop:~$ <b>robaccia-admin createproject myprj</b>
joe@joe-laptop:~$ <b>cd myprj/</b>
<i>/home/joe/myprj</i>
joe@joe-laptop:~/myprj$ <b>robaccia-admin addmodelview employees</b>
<i> created views/employees.py 
 created models/employees.py 
 created templates/employees/list.html 
 created templates/employees/retrieve.html 
 created templates/employees/get_edit_form.html 
 created templates/employees/get_new_form.html </i>
joe@joe-laptop:~/myprj$ <b>vim models/employees.py</b>
joe@joe-laptop:~/myprj$ <b>cat models/employees.py</b>
<i>from sqlalchemy import Table, Column, Integer, String
import dbconfig
table = Table('employees', dbconfig.metadata,
        Column('id', Integer(), primary_key=True),
        Column('name', String(250)), 
        Column('title', String(250)),
        Column('office_number', Integer()),
        )
</i>
joe@joe-laptop:~/myprj$ <b>robaccia-admin createdb</b>
joe@joe-laptop:~/myprj$ <b>robaccia-admin run</b>
<i>Serving HTTP on 0.0.0.0 port 3100 ...</i>
</pre>
<p>The database is initially empty.  Click on New to create a new member in the collection.  </p>
<p><img alt="Web page: New" src="http://bitworking.org/images/2007/05/robaccia-employees-new.png" /></p>
<p>Creating a new employee.</p>
<p><img alt="Web page: Form for creating a new employee" src="http://bitworking.org/images/2007/05/robaccia-employees-new-form.png" /></p>
<p>Our collection list afer adding couple new employees. Note the link to individual employees.</p>
<p><img alt="Web page: List of two added employees" src="http://bitworking.org/images/2007/05/robaccia-employees-list.png" /></p>
<p>From an individual collection member we can edit and delete the employee.</p>
<p><img alt="Web page: A single employee" src="http://bitworking.org/images/2007/05/robaccia-employees-retrieve.png" /></p>
<p>A form for editing the employee.</p>
<p><img alt="Web page: Editing a single employee" src="http://bitworking.org/images/2007/05/robaccia-employees-edit-form.png" /></p>
<h3>Lessons</h3>
<p>We came up with a rather simple database to web framework, but in reality
 haven't lost any flexibility over the original Robaccia. All the pieces 
 of URI dispatching, views and templates are present, all we did
 was pave the happy path.
</p>
<p>We paved the happy path by embracing the following constraints:</p>
<p><ol>
<li>All resource fit into a collection.</li>
<li>A single URI path structure.</li>
<li>A fixed model interface: SQLAlchemy.</li>
<li>A fixed project layout.</li>
<li>WSGI as method of communication between components.</li>
<li>A single media-type for any single view. (You can
        have different views with different media-types that
        use the same model.) 
    </li>
<li>Not really mentioned explicitly, but all the configuration
        was done through Python files.</li>
</ol></p>
<h3>Observations</h3>
<p>The code so far has renderers and parsers for HTML and
HTML forms, but we could easily add support for JSON or Atom.
</p>
<p>There isn't much that ties us to SQLAlchemy; just DefaultModelDispatcher
and the initial files put down by 'robaccia addmodelview'. We could easily 
switch out to another ORM, or even drop the RDBMS and move to another
kind of data store.
</p>
<p>There is a whole slew of stuff that hasn't been done like 
   handling changes to the database, deployment, security,  
   large collections that require paging, etc. Those are all solvable
   problems, and not the point of this exercise, which was to 
   demonstrate applying constraints to reduce cognitive and manual 
  load to create a Rails/Django-like web framework. 
</p>
<p>The code is now available on <a href="http://code.google.com/p/robaccia/">code.google.com</a>.
If you run it under Python 2.5 you will only need to install SQLAlchemy and Genshi. 
For Python 2.4 you will also need to install wsgiref.
</p>
  <div class="commentContent" id="X1">
    I'm not quite to the point in my projects where I can leverage WSGI directly, so I've done something very similar within TurboGears.  Take a look:
http://www.graffitiweb.org/blog/2007/05/25/restresource-03-crud-for-turbogears/
or directly to the code at:
http://microapps.googlecode.com/svn/restresource/tags/0.3/

One thing, I've been thinking about is a slight tweak to your WSGICollection url scheme where /col/1;edit_form should be /col;1/edit_form and /col/add_form.  The advantage to this URL scheme is that context becomes a lot more clear cut. A post to "./" from the forms will always go to the right place--and that way the form doesn't need to know where it lives, so to speak.
    <p class="commentByLine">Posted by
       <a href="http://www.graffitiweb.org">sky</a> on <a href="#X1" title="2007-05-25T14:54:43.811326">2007-05-25</a>
    </p>
</div>
  

  </div>

  <script type="text/javascript" charset="utf-8">
    fetch('/u/mentions').then(function(resp) {
      if (!resp.ok) {
        return
      }
      resp.text().then(function(text) {
        document.getElementById('mentions').innerHTML = text;
      });
    });
  </script>
  <div id=mentions>
  </div>

  
    

  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://bitworking.org/news/2007/05/Gloves';
      this.page.identifier = 'https://bitworking.org/news/2007/05/Gloves';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://bitworking-1.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    
    <div class="PageNavigation">
      
      <a class="prev" href="/news/2007/05/The-W3C-s-next-generation-HTML-specification">&laquo;
        The W3C's next-generation HTML specification</a>
      
      
      <a class="next"
        href="/news/2007/05/draft-ietf-atompub-protocol-15">draft-ietf-atompub-protocol-15 &raquo;</a>
      
    </div>
    

    <h2 class="footer-heading">BitWorking</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              BitWorking
            
            </li>
            
            <li><a rel=me class="u-email" href="mailto:joe@bitworking.org">joe@bitworking.org</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jcgregorio" rel=me><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jcgregorio</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/bitworking" rel=me><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">bitworking</span></a>

          </li>
          

          <li>
            <a href="https://plus.google.com/+JoeGregorio" rel=me>
              <svg enable-background="new 0 0 128 128" height="16px" viewBox="0 0 128 128" width="16px" xml:space="preserve">
                <circle cx="64" cy="64" fill="gray" r="64"/>
                <path d="M49.424,97.875c-19.018,0-34.491-15.193-34.491-33.874c0-18.68,15.473-33.875,34.491-33.875 c8.318,0,16.354,2.952,22.624,8.309l-8.771,9.899c-3.838-3.279-8.758-5.086-13.853-5.086c-11.652,0-21.13,9.31-21.13,20.752 c0,11.441,9.479,20.75,21.13,20.75c9.858,0,16.311-4.723,18.407-13.197H49.587V58.432h32.347v6.562 C81.934,84.659,68.869,97.875,49.424,97.875z"
                fill="#FFFFFF"/>
                <polygon fill="#FFFFFF" points="117.934,58.438
                107.934,58.438 107.934,48.438 99.934,48.438 99.934,58.438
                89.934,58.438     89.934,66.438 99.934,66.438 99.934,76.438
                107.934,76.438 107.934,66.438 117.934,66.438   "/>
              </svg>
              <span class="username">JoeGregorio</span></a>
          </li>
        </ul>
      </div>

      <div class="h-card footer-col footer-col-3">
        <p class="p-note">Joe Gregorio - REST, Web, Python, Go, APIs, Dad, Husband, Maker, or any linear combination of such. Googler.
</p>
        <a class="p-name u-url" href="https://bitworking.org" style="display: none"><img
          class="u-photo" src="/images/joe2016.jpg" alt="" />Joe Gregorio</a>
        <a rel=me class="u-email" href="mailto:joe@bitworking.org">joe@bitworking.org</a><
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
