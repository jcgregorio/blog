<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="https://bitworking.org/news/feed/index.atom" rel="self" type="application/atom+xml" /><link href="https://bitworking.org/" rel="alternate" type="text/html" /><updated>2017-11-12T11:42:30-05:00</updated><id>https://bitworking.org/</id><title type="html">BitWorking</title><subtitle>Joe Gregorio - REST, Web, Python, Go, APIs, Dad, Husband, Maker, or any linear combination of such. Googler.
</subtitle><entry><title type="html">The Shoelace Formula via Geometric Algebra</title><link href="https://bitworking.org/news/ga/area.html" rel="alternate" type="text/html" title="The Shoelace Formula via Geometric Algebra" /><published>2017-11-12T00:00:00-05:00</published><updated>2017-11-12T00:00:00-05:00</updated><id>https://bitworking.org/news/ga/area</id><content type="html" xml:base="https://bitworking.org/news/ga/area.html">&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;
    img {
      vertical-align: baseline;
    }

    th {
      background: #fff;
    }

    body {counter-reset: h3}
    h3 {counter-reset: h4}
    h4 {counter-reset: h5}
    h5 {counter-reset: h6}

    h3:before {counter-increment: h3; content: counter(h3) &quot;. &quot;}
    h4:before {counter-increment: h4; content: counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;}
    h5:before {counter-increment: h5; content: counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;}
    h6:before {counter-increment: h6; content: counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;}

  &lt;/style&gt;
  &lt;script src=&quot;/js/ga2d.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/draw_ga2d.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;p&gt;
    Continuing our exploration of Geometric Algebra, let's look at calculating
    area. GA might have some advantages here since the exterior product of two
    vectors is the area of the parallelogram they define.
  &lt;/p&gt;

  &lt;dl&gt;
    &lt;dd&gt;$$ \boldsymbol{a} \wedge \boldsymbol{b} $$&lt;/dd&gt;
  &lt;/dl&gt;

  &lt;canvas id=parallelogram width=300 height=300&gt;&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      var a = ga2d.vec(Math.sqrt(2)/2, Math.sqrt(2)/2);
      var b = ga2d.vec(Math.sqrt(2)/2, -Math.sqrt(2)/2);
      var ab = ga2d.add(a, b);
      var f = new draw_ga2d.Frame(document.getElementById('parallelogram'));
      f.vec(a, &quot;a&quot;);
      f.vecFrom(b, a, &quot;b&quot;);
      f.region([
        [0,0,0,0],
        a,
        ab,
        b,
      ], &quot;&quot;, &quot;rgba(100, 0, 255, 0.2)&quot;);
      f.draw();
    })();
  &lt;/script&gt;

  &lt;p&gt;
    We are being a little sloppy here as the exterior product really gives
    you a scalar times &lt;b&gt;e&lt;sub&gt;12&lt;/sub&gt;&lt;/b&gt;, but we'll ignore that for the
    rest of this article, presuming we'll just read off the scalar as the
    oriented area.
  &lt;/p&gt;

  &lt;p&gt;The oriented area of the triangle defined by the two vectors
    and the origin is half of the exterior product:
  &lt;/p&gt;

  &lt;dl&gt;
    &lt;dd&gt;$$\frac{1}{2} \boldsymbol{a} \wedge \boldsymbol{b}$$&lt;/dd&gt;
  &lt;/dl&gt;

  &lt;canvas id=area width=300 height=300&gt;&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      var a = ga2d.vec(Math.sqrt(2)/2, Math.sqrt(2)/2);
      var b = ga2d.vec(Math.sqrt(2)/2, -Math.sqrt(2)/2);
      var ab = ga2d.add(a, b);
      var f = new draw_ga2d.Frame(document.getElementById('area'));
      f.vec(a, &quot;a&quot;);
      f.vecFrom(b, a, &quot;b&quot;);
      f.region([
        [0,0,0,0],
        a,
        ab,
      ], &quot;&quot;, &quot;rgba(100, 0, 255, 0.2)&quot;);
      f.draw();
    })();
  &lt;/script&gt;

  &lt;p&gt;
    Before going any further we need to pause for some nomenclature.  Up until
    this point we've only spoken of vectors. If we start talking about
    geometric shapes in ‚Ñù&lt;sup&gt;2&lt;/sup&gt; we are going to need to talk about
    points, which we will also represent as vectors with the implicit
    understanding that a point is a vector rooted at the origin,
    and that the difference of two points is just a vector.
  &lt;/p&gt;

  &lt;p&gt;
    So let's look at determining the area of a triangle defined by any three
    points. One way would be to take the differences of pairs of points on
    the triange to construct vectors that represent two sides of the triange.
    Note that we are also picking an orientation, so we will work in a
    clockwise manner.
 &lt;/p&gt;

  &lt;canvas id=triangle width=300 height=300&gt;&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      var a = ga2d.vec(Math.sqrt(2)/2, Math.sqrt(2)/2);
      var b = ga2d.vec(Math.sqrt(2)/2, -Math.sqrt(2)/2);
      var c = [0,0,0,0];
      var f = new draw_ga2d.Frame(document.getElementById('triangle'));
      f.vecFrom(ga2d.sub(a, c), c, &quot;a&quot;);
      f.vecFrom(ga2d.sub(b, a), a, &quot;b&quot;);
      f.vecFrom(ga2d.sub(c, b), b, &quot;c&quot;);
      f.region([
        c,
        a,
        b,
      ], &quot;&quot;, &quot;rgba(100, 0, 255, 0.2)&quot;);
      f.draw();
    })();
  &lt;/script&gt;

  &lt;p&gt;
    To calculate A, the area of the triangle, we take the exterior product
    of those two vectors. First we calculate 2A:
  &lt;/p&gt;

  &lt;dl&gt;
    &lt;dd&gt;
      $$
        \begin{align*}
        2 A &amp;= (\boldsymbol{b} - \boldsymbol{a}) \wedge (\boldsymbol{c} - \boldsymbol{b}) \\
        &amp;= \boldsymbol{b} \wedge (\boldsymbol{c} - \boldsymbol{b}) - \boldsymbol{a} \wedge (\boldsymbol{c} - \boldsymbol{b}) \\
        &amp;= \boldsymbol{b} \wedge \boldsymbol{c} - \boldsymbol{b} \wedge \boldsymbol{b}  - \boldsymbol{a} \wedge \boldsymbol{c} + \boldsymbol{a} \wedge \boldsymbol{b} \\
        &amp;= \boldsymbol{b} \wedge \boldsymbol{c} - 0 - \boldsymbol{a} \wedge \boldsymbol{c} + \boldsymbol{a} \wedge \boldsymbol{b} \\
        &amp;= \boldsymbol{b} \wedge \boldsymbol{c} - \boldsymbol{a} \wedge \boldsymbol{c} + \boldsymbol{a} \wedge \boldsymbol{b} \\
        &amp;= \boldsymbol{b} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{a} + \boldsymbol{a} \wedge \boldsymbol{b} \\
        &amp;= \boldsymbol{a} \wedge \boldsymbol{b} + \boldsymbol{b} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{a}
        \end{align*}
      $$
    &lt;/dd&gt;
  &lt;/dl&gt;

  &lt;p&gt;Which gives us:&lt;/p&gt;

  &lt;dl&gt;
    &lt;dd&gt;
      $$
        \begin{align*}
        A = \frac{1}{2} (\boldsymbol{a} \wedge \boldsymbol{b} + \boldsymbol{b} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{a})
        \end{align*}
      $$
    &lt;/dd&gt;
  &lt;/dl&gt;
  &lt;p&gt;
    So the oriented area of the triange is just half the exterior product of all
    the pairs of vectors as you progress clockwise around the triange.
  &lt;/p&gt;
  &lt;p&gt;
    Note that if you have a rectangle:
  &lt;/p&gt;

  &lt;canvas id=rect width=300 height=300&gt;&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      var a = ga2d.vec(0, 0);
      var b = ga2d.vec(0, 2);
      var c = ga2d.vec(1, 2);
      var d = ga2d.vec(1, 0);
      var ab = ga2d.add(a, b);
      var f = new draw_ga2d.Frame(document.getElementById('rect'));
      f.vecFrom(ga2d.sub(b, a), a, &quot;b&quot;);
      f.vecFrom(ga2d.sub(c, b), b, &quot;c&quot;);
      f.vecFrom(ga2d.sub(d, c), c, &quot;d&quot;);
      f.vecFrom(ga2d.sub(a, d), d, &quot;a&quot;);
      /*
      f.vec(c, &quot;c&quot;);
      */
      f.region([
        a,
        b,
        c,
        d
      ], &quot;&quot;, &quot;rgba(100, 0, 255, 0.2)&quot;);
      f.draw();
    })();
  &lt;/script&gt;

  &lt;p&gt;
    You can triangulate it:
  &lt;/p&gt;

  &lt;canvas id=triangulate width=300 height=300&gt;&lt;/canvas&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      var a = ga2d.vec(0, 0);
      var b = ga2d.vec(0, 2);
      var c = ga2d.vec(1, 2);
      var d = ga2d.vec(1, 0);

      var delta = ga2d.vec(1, 0);
      var a_d = ga2d.add(a, delta);
      var b_d = ga2d.add(b, delta);
      var c_d = ga2d.add(c, delta);
      var d_d = ga2d.add(d, delta);

      var f = new draw_ga2d.Frame(document.getElementById('triangulate'));
      f.vecFrom(ga2d.sub(b, a), a, &quot;b&quot;);
      f.vecFrom(ga2d.sub(c, b), b, &quot;c&quot;);
      f.vecFrom(ga2d.sub(a, c), c, &quot;a&quot;);

      f.vecFrom(ga2d.sub(d_d, c_d), c_d, &quot;d&quot;);
      f.vecFrom(ga2d.sub(a_d, d_d), d_d, &quot;a&quot;);
      f.vecFrom(ga2d.sub(c_d, a_d), a_d, &quot;c&quot;);
      /*
      f.vec(c, &quot;c&quot;);
      */
      f.region([
        a,
        b,
        c,
      ], &quot;&quot;, &quot;rgba(100, 0, 255, 0.2)&quot;);
      f.region([
        a_d,
        c_d,
        d_d,
      ], &quot;&quot;, &quot;rgba(100, 0, 255, 0.2)&quot;);
      f.draw();
    })();
  &lt;/script&gt;

  &lt;p&gt;
    And now we see that we can calculate the volume of the rectangle as
    the sum of the area of the two triangles:
  &lt;/p&gt;

  &lt;dl&gt;
    &lt;dd&gt;
      $$
        \begin{align*}
        A &amp;= 
        \frac{1}{2} (\boldsymbol{a} \wedge \boldsymbol{b} + \boldsymbol{b} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{a})
        +
        \frac{1}{2} (\boldsymbol{a} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{d} + \boldsymbol{d} \wedge \boldsymbol{a}) \\
        &amp;= \frac{1}{2} (\boldsymbol{a} \wedge \boldsymbol{b} + \boldsymbol{b} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{a} + \boldsymbol{a} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{d} + \boldsymbol{d} \wedge \boldsymbol{a}) \\
        &amp;= \frac{1}{2} (\boldsymbol{a} \wedge \boldsymbol{b} + \boldsymbol{b} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{a} - \boldsymbol{c} \wedge \boldsymbol{a} + \boldsymbol{c} \wedge \boldsymbol{d} + \boldsymbol{d} \wedge \boldsymbol{a}) \\
        &amp;= \frac{1}{2} (\boldsymbol{a} \wedge \boldsymbol{b} + \boldsymbol{b} \wedge \boldsymbol{c} + 0 + \boldsymbol{c} \wedge \boldsymbol{d} + \boldsymbol{d} \wedge \boldsymbol{a}) \\
        &amp;= \frac{1}{2} (\boldsymbol{a} \wedge \boldsymbol{b} + \boldsymbol{b} \wedge \boldsymbol{c} + \boldsymbol{c} \wedge \boldsymbol{d} + \boldsymbol{d} \wedge \boldsymbol{a}) \\
        \end{align*}
      $$
    &lt;/dd&gt;
  &lt;/dl&gt;

  &lt;p&gt;
    Again we can see that to calculate the area we just take 1/2 the exterior product of pairs of points
    as you progress around the perimenter of the shape, and this can be
    applied to any simple polygon. You might recongize this as the &lt;a
      href=&quot;https://en.wikipedia.org/wiki/Shoelace_formula&quot;&gt;Shoelace
      Formula&lt;/a&gt;, and comparing the above proof to the explanations in the
    Wikipedia article really drives home the succinct and expressive power
    of GA.
  &lt;/p&gt;</content><author><name></name></author><summary type="html">img { vertical-align: baseline; }</summary></entry><entry><title type="html">Custom Element Spinner</title><link href="https://bitworking.org/news/2017/11/busy" rel="alternate" type="text/html" title="Custom Element Spinner" /><published>2017-11-08T00:00:00-05:00</published><updated>2017-11-08T00:00:00-05:00</updated><id>https://bitworking.org/news/2017/11/busy</id><content type="html" xml:base="https://bitworking.org/news/2017/11/busy">&lt;p&gt;
  Now that Custom Elements has reached v1 and is starting to appear in
  browsers, let's make some elements. We'll start with one of the simplest
  elements possible, a busy spinner, or activity indicator.
&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;Caveats:&lt;/b&gt; No accessibility.
&lt;/p&gt;

&lt;script src=&quot;webcomponents-sd-ce.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;
  spinner-bw {
    display: none;
    border-radius: 50%;
    width: 2em;
    height: 2em;
    border: 0.4em solid #A6CEE3;
    border-left: 0.4em solid #1F78B4;
    animation: spinner-bw-spin 1.5s infinite linear;
  }

  spinner-bw[active] {
    display: inline-block;
  }

  @keyframes spinner-bw-spin {
    0% {
      transform:
      rotate(0deg);
    }
    100% {
      transform:
      rotate(360deg);
    }
  }
&lt;/style&gt;

&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
  window.customElements.define('spinner-bw', class extends HTMLElement {
      get active() { return this.hasAttribute('active'); }
      set active(val) {
        if (val) {
          this.setAttribute('active', '');
        } else {
          this.removeAttribute('active');
        }
      }
    });
&lt;/script&gt;

&lt;p&gt;
  &lt;button id=toggle&gt;Toggle&lt;/button&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;spinner-bw id=spinner active&gt;&lt;/spinner-bw&gt;
&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
  (function () {
    var spinner = document.getElementById('spinner');
    document.getElementById('toggle').addEventListener('click', function() {
      spinner.active = !spinner.active;
    });
  })();
&lt;/script&gt;

&lt;script src=&quot;https://gist.github.com/jcgregorio/67a367a2dd452475945817ebba2f836f.js&quot;&gt;&lt;/script&gt;</content><author><name></name></author><summary type="html">Now that Custom Elements has reached v1 and is starting to appear in browsers, let's make some elements. We'll start with one of the simplest elements possible, a busy spinner, or activity indicator. Caveats: No accessibility.</summary></entry><entry><title type="html">Organizing around State</title><link href="https://bitworking.org/news/2017/08/organizing-around-state" rel="alternate" type="text/html" title="Organizing around State" /><published>2017-08-15T00:00:00-04:00</published><updated>2017-08-15T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/08/organizing-around-state</id><content type="html" xml:base="https://bitworking.org/news/2017/08/organizing-around-state">&lt;p&gt;
  This is &lt;a
    href=&quot;/news/2017/08/l-systems-with-redux-and-statereflector&quot;&gt;
    L-Systems with Redux and StateReflector&lt;/a&gt;, but now with more
  organization around updating the state and around efficiently updating
  the DOM to changes in the state. That is, a simple app for drawing
  L-Systems, where making changes to the parameters (Length, Angle) is stored
  in the URL fragment identifier, thus creating a permalink for any
  selections a user makes. The state of the page is kept in a Redux state
  store and we use &lt;a
    href=&quot;https://gist.github.com/jcgregorio/fee80c6484d718f7e037916ba323abf6#file-urlreflector-js-L130&quot;&gt;StateTools.getDelta()&lt;/a&gt;
  to store that changing state in the URL fragment, and also pull the state
  out of the URL and push it into the state when the URL changes.
&lt;/p&gt;

&lt;label for=length&gt;Length:&lt;/label&gt;
&lt;input type=range name=length id=length min=1 max=10 /&gt;
&lt;span style=&quot;padding: 0 10px;&quot; id=lengthDisplay&gt;&lt;/span&gt;
&lt;br&gt;
&lt;label for=angle&gt;Angle:&lt;/label&gt;
&lt;input type=range name=angle id=angle min=0.01 max=1 step=0.01 /&gt;
&lt;span style=&quot;padding: 0 10px;&quot; id=angleDisplay&gt;&lt;/span&gt;
&lt;br&gt;
&lt;canvas width=600 height=600&gt;&lt;/canvas&gt;

&lt;p&gt;
  The old render() function in our &lt;a
    href=&quot;/news/2017/08/l-systems-with-redux-and-statereflector&quot;&gt;previous
    iteration&lt;/a&gt; was inefficent, every time 'state' changed all the elements
  were updated, even if the new value wasn't different from the old value.
&lt;/p&gt;

&lt;p&gt;
  To make this more efficient we can leverage (the newly renamed
  StateReflector to StateTools) &lt;a
    href=&quot;https://gist.github.com/jcgregorio/fee80c6484d718f7e037916ba323abf6#file-urlreflector-js-L130&quot;&gt;StateTools.getDelta()&lt;/a&gt;,
  which returns the differences between the old state and the new state, so we
  only have to update elements that have changed.  Similarly on the side of
  updating the state, we can consolidate some code around responding to
  events.
&lt;/p&gt;

&lt;p&gt;The markup for the page is straightforward:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/jcgregorio/38ca7d599395902f2ad2765fc7853b5d.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;And the JS is now much more compact also, coming in at just 73 lines of code:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/jcgregorio/523da36281c6fb7d97890596e5304569.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;
  What makes the main code so compact is the use of Redux for state
  management, and Binder, which is a small class for mapping state changes
  to and from HTML elements:
&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/jcgregorio/482c5b6b7ee4e2c78004a5df7fe48461.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;
  Binder is able to work because of some of the uniformity in how native HTML
  elements work, in particular that events are only generated via external
  stimuli. That is, merely changing the state of an element doesn't generate
  an event, for example, changing the checked value of a checkbox via the DOM
  does not generate an 'input' or 'changed' event.
&lt;/p&gt;
&lt;p&gt;
  This means that we should never encounter an infinite cascade of events. If
  an element generates an event and that changes the state, the new state will
  then be reflected in the elements, but since no new events are generted then
  the update cycle stops there. The general principles of not generating
  events on DOM changes, and announcing changes in state via events, are ones
  that should carry over when creating our own Custom Elements, which we'll
  get to in a later installment.
&lt;/p&gt;

&lt;p&gt;
  In general the code is fairly simplistic, I've only coded the happy-path,
  and since our '&lt;a
    href=&quot;https://gist.github.com/jcgregorio/fee80c6484d718f7e037916ba323abf6#file-urlreflector-js-L130&quot;
    target=&quot;_blank&quot;&gt;StateTools.getDelta&lt;/a&gt;' algorithm is crude we can't
  really handle complex state objects, but there are plenty of other opensouce
  object diffing libraries that can be used to replace the simple version used
  here. OTOH, there is enough code there to prove out the idea, that building
  these one and two way bindings using state objects is not only feasible, but
  it dramatically improves the code and makes it easier to reason about the
  behavior of the system.
&lt;/p&gt;

&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
this.StateTools = this.StateTools || {};

(function(sr) {
  &quot;use strict&quot;;

  // A Promise that resolves when DOMContentLoaded has fired.
  sr.DomReady = new Promise(function(resolve, reject) {
    if (document.readyState != 'loading') {
      // If readyState is already past loading then
      // DOMContentLoaded has already fired, so just resolve.
      resolve();
    } else {
      document.addEventListener('DOMContentLoaded', resolve);
    }
  });

  // Namespace for utilities for working with URL query strings.
  sr.query = {};

  // fromObject takes an object and encodes it into a query string.
  //
  // The reverse of this function is toObject.
  sr.query.fromObject = function(o) {
    var ret = [];
    Object.keys(o).sort().forEach(function(key) {
      if (Array.isArray(o[key])) {
        o[key].forEach(function(value) {
          ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        })
      } else if (typeof(o[key]) == 'object') {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(sr.query.fromObject(o[key])));
      } else {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(o[key]));
      }
    });
    return ret.join('&amp;');
  }


  // toObject decodes a query string into an object
  // using the 'target' as a source for hinting on the types
  // of the values.
  //
  //   &quot;a=2&amp;b=true&quot;
  //
  // decodes to:
  //
  //   {
  //     a: 2,
  //     b: true,
  //   }
  //
  // When given a target of:
  //
  //   {
  //     a: 1.0,
  //     b: false,
  //   }
  //
  // Note that a target of {} would decode
  // the same query string into:
  //
  //   {
  //     a: &quot;2&quot;,
  //     b: &quot;true&quot;,
  //   }
  //
  // Only Number, String, Boolean, Object, and Array of String hints are supported.
  sr.query.toObject = function(s, target) {
    var target = target || {};
    var ret = {};
    var vars = s.split(&quot;&amp;&quot;);
    for (var i=0; i&lt;vars.length; i++) {
      var pair = vars[i].split(&quot;=&quot;, 2);
      if (pair.length == 2) {
        var key = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair[1]);
        if (target.hasOwnProperty(key)) {
          switch (typeof(target[key])) {
            case 'boolean':
              ret[key] = value==&quot;true&quot;;
              break;
            case 'number':
              ret[key] = Number(value);
              break;
            case 'object': // Arrays report as 'object' to typeof.
              if (Array.isArray(target[key])) {
                var r = ret[key] || [];
                r.push(value);
                ret[key] = r;
              } else {
                ret[key] = sr.query.toObject(value, target[key]);
              }
              break;
            case 'string':
              ret[key] = value;
              break;
            default:
              ret[key] = value;
          }
        } else {
          ret[key] = value;
        }
      }
    }
    return ret;
  }

  // Namespace for utilities for working with Objects.
  sr.object = {};

  // Returns true if a and b are equal, covers Boolean, Number, String and
  // Arrays and Objects.
  sr.object.equals = function(a, b) {
    if (typeof(a) != typeof(b)) {
      return false
    }
    var ta = typeof(a);
    if (ta == 'string' || ta == 'boolean' || ta == 'number') {
      return a === b
    }
    if (ta == 'object') {
      if (Array.isArray(ta)) {
        return JSON.stringify(a) == JSON.stringify(b)
      } else {
        return sr.query.fromObject(a) == sr.query.fromObject(b)
      }
    }
  }

  // Returns an object with only values that are in o that are different
  // from d.
  //
  // Only works shallowly, i.e. only diffs on the attributes of
  // o and d, and only for the types that sr.object.equals supports.
  sr.object.getDelta = function (o, d) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (!sr.object.equals(o[key], d[key])) {
        ret[key] = o[key];
      }
    });
    return ret;
  };

  // Returns a copy of object o with values from delta if they exist.
  sr.object.applyDelta = function (delta, o) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (delta.hasOwnProperty(key)) {
        ret[key] = JSON.parse(JSON.stringify(delta[key]));
      } else {
        ret[key] = JSON.parse(JSON.stringify(o[key]));
      }
    });
    return ret;
  };

  // Track the state of a page and reflect it to and from the URL.
  //
  // store - A Redux store.
  //        The state must be on Object and all the values in the Object
  //        must be Number, String, Boolean, Object, or Array of String.
  //        Doesn't handle NaN, null, or undefined.
  //
  // dispatch - A function called to update the state in store.
  sr.urlReflector = function(store, dispatch) {
    var defaultState = store.getState();
    var lastState = store.getState();
    store.subscribe(function() {
      var state = store.getState();
      if (Object.keys(sr.object.getDelta(lastState, state)).length &gt; 0) {
        lastState = state;
        var q = sr.query.fromObject(sr.object.getDelta(state, defaultState));
        window.history.pushState(null, &quot;&quot;, window.location.origin + window.location.pathname + &quot;#&quot; +  q);
      }
    });

    // stateChangeFromURL should be called when DOMContentLoaded.
    var stateChangeFromURL = function() {
      var delta = sr.query.toObject(window.location.hash.slice(1), defaultState);
      lastState = sr.object.applyDelta(delta, defaultState);
      dispatch(lastState);
    }
    window.addEventListener('popstate', stateChangeFromURL);
    StateTools.DomReady.then(stateChangeFromURL);
  }

  var dup = (o) =&gt; JSON.parse(JSON.stringify(o));

  // Binder makes it easy to setup bindings between data stored in a Redux
  // store and HTML elements.
  class Binder {

    // store - A Redux store.
    // dispatch - A function called to update the state in store.
    // ele - The root element where all element searches begin from, i.e.
    //     querySelectorAll is run on this element. Defaults to document.
    constructor(store, dispatch, ele = document) {
      this.to = [];
      this.store = store;
      this.oldState = {}; // Empty object so that filling in the default value triggers writes to the elements.
      this.ele = ele;
      this.dispatch = dispatch;
      this.store.subscribe(this._newState.bind(this));
    }

    _newState() {
      let delta = sr.object.getDelta(this.store.getState(), this.oldState);
      this.to.forEach(item =&gt; {
        let value = delta;
        for (var i = 0; i &lt; item.parsedPath.length; i++) {
          value = value[item.parsedPath[i]];
          if (value === undefined) {
            return
          }
        }
        item.func(value);
      });
    }

    // add - Add a binding between some part of the state and an element.
    //
    //  statePath - A &quot;.&quot; separated path into the state object. Ex:
    //        The statePath &quot;a.b&quot; selects 2 in the object {a: { b: 2, c: 3}}.
    //        The empty statePath, &quot;&quot;, selects any change to the state.
    //  query - A CSS selector that determines which element(s) are being bound.
    //          The selector will be run from the 'ele' passed into the
    //          constructor. Ex: &quot;div &gt; li&quot;, &quot;length&quot;.
    //  to - Defines how the state maps to the element. Can be an object of the form:
    //
    //    {
    //      attr: &quot;input&quot;,
    //      content: false,
    //    };
    //
    //    Where 'attr' is the name of the DOM attribute to set.
    //    If content is true then the attribute is treated as a Content attribute.
    //    Not specifying 'content' is the same as specifying content: false.
    //
    //    The value of 'to' can also be a function that takes a single argument of the state
    //    value at the given statePath. The function will be called every time
    //    value at the given statePath changes. This can be used, for example, to expand
    //    templates based on the updated state.
    //
    //  from - [Optional] Defines how the elements value maps to the state. Can be an object of the form:
    //
    //    {
    //      event: &quot;click&quot;,
    //      proc: e =&gt; e.target.dataset.foo,
    //      filter: e =&gt; e.target.tagName == &quot;LI&quot;,
    //    }
    //
    //    Where 'event' is the name of the event to register for. When the
    //    event is fired 'proc' will extract the value to store in the state
    //    at statePath. The 'filter' is optional and can be used to filter out
    //    unwanted events.
    //
    //    If the 'listener' is set on the object then its value, which should
    //    be a function, is added as an event handler to the selected
    //    elements. The function should update the store's state when called.
    //
    add(statePath, query, to, from) {
      let parsedPath = statePath.split(&quot;.&quot;);
      if (statePath === &quot;&quot;) {
        parsedPath = [];
      }
      let pathLeadSegments = statePath.split(&quot;.&quot;);
      let finalPathSegment = pathLeadSegments.pop();
      let elements = [].slice.call(this.ele.querySelectorAll(query));
      let toFunc = undefined;
      if (typeof to === &quot;object&quot;) {
        if (to.content) {
          toFunc = state =&gt; elements.forEach(ele =&gt; ele.setAttribute(to.attr, state));
        } else {
          toFunc = state =&gt; elements.forEach(ele =&gt; ele[to.attr] = state);
        }
      } else {
        toFunc = to;
      }
      this.to.push({
        func: toFunc,
        parsedPath: parsedPath,
      });

      if (!from) {
        return
      }

      if (from.proc) {
        elements.forEach(ele =&gt; ele.addEventListener(from.event, e =&gt; {
          if (from.filter &amp;&amp; !from.filter(e)) {
            return
          }
          let state = dup(this.store.getState());
          pathLeadSegments.forEach(segment =&gt; { state = state[segment]; });
          state[finalPathSegment] = from.proc(e);
          this.dispatch(state);
        }));
      } else if (from.listener) {
        elements.forEach(ele =&gt; ele.addEventListener(from.event, from.listener));
      }
    }
  }

  sr.Binder = Binder;

})(this.StateTools);
&lt;/script&gt;

&lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
  (function () {
    let dup = (o) =&gt; JSON.parse(JSON.stringify(o));

    let canvas = document.querySelector(&quot;canvas&quot;),
      ctx = canvas.getContext(&quot;2d&quot;),
      width = canvas.width,
      height = canvas.height;

    let rules = {
      &quot;X&quot;: &quot;F-[[X]+X]+F[+FX]-X&quot;,
      &quot;F&quot;: &quot;FF&quot;,
      &quot;+&quot;: &quot;+&quot;,
      &quot;-&quot;: &quot;-&quot;,
      &quot;[&quot;: &quot;[&quot;,
      &quot;]&quot;: &quot;]&quot;,
    }
    let E = (s) =&gt; s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot;;
    let L = E(E(E(E(E(&quot;X&quot;)))));

    function draw(x, y, len, angle) {
      let p = { x: x, y: y, a: 3 };
      let stack = [];
      ctx.beginPath()
      ctx.moveTo(p.x, p.y)
      L.split(&quot;&quot;).forEach(function(ch) {
        if (ch == &quot;F&quot;) {
          p.x += len*Math.sin(p.a);
          p.y += len*Math.cos(p.a);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
        } else if (ch == &quot;-&quot;) {
          p.a += angle;
        } else if (ch == &quot;+&quot;) {
          p.a -= angle;
        } else if (ch == &quot;[&quot;) {
          stack.push(dup(p));
        } else if (ch == &quot;]&quot;) {
          p = stack.pop();
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
        }
      })
    }

    function render(state) {
      ctx.clearRect(0, 0, width, height);
      draw(width/2, height, state.length, state.angle);
    }

    // Setup the Redux state store.
    let defaultState = {
      length: 7,
      angle: 0.4,
    };

    let updateState = (state = defaultState, action) =&gt; {
      if (action.type == &quot;REPLACE_ALL&quot;) {
        state = dup(action.value);
      }
      return state;
    };
    let store = Redux.createStore(updateState);
    let dispatch = state =&gt; store.dispatch({type: &quot;REPLACE_ALL&quot;, value: state});

    // Bind state to elements.
    let binder = new StateTools.Binder(store, dispatch);
    binder.add(&quot;length&quot;, &quot;#length&quot;,        {attr: &quot;value&quot;},      {event: &quot;input&quot;, proc: e =&gt; +e.target.value});
    binder.add(&quot;angle&quot;,  &quot;#angle&quot;,         {attr: &quot;value&quot;},      {event: &quot;input&quot;, proc: e =&gt; +e.target.value});
    binder.add(&quot;length&quot;, &quot;#lengthDisplay&quot;, {attr: &quot;innerText&quot;});
    binder.add(&quot;angle&quot;,  &quot;#angleDisplay&quot;,  {attr: &quot;innerText&quot;});
    binder.add(&quot;&quot;,       &quot;canvas&quot;,         render);

    // Hook up urlReflector.
    StateTools.urlReflector(store, dispatch);
  })();
&lt;/script&gt;</content><author><name></name></author><summary type="html">This is L-Systems with Redux and StateReflector, but now with more organization around updating the state and around efficiently updating the DOM to changes in the state. That is, a simple app for drawing L-Systems, where making changes to the parameters (Length, Angle) is stored in the URL fragment identifier, thus creating a permalink for any selections a user makes. The state of the page is kept in a Redux state store and we use StateTools.getDelta() to store that changing state in the URL fragment, and also pull the state out of the URL and push it into the state when the URL changes.</summary></entry><entry><title type="html">L-Systems with Redux and StateReflector</title><link href="https://bitworking.org/news/2017/08/l-systems-with-redux-and-statereflector" rel="alternate" type="text/html" title="L-Systems with Redux and StateReflector" /><published>2017-08-06T00:00:00-04:00</published><updated>2017-08-06T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/08/l-systems-with-redux-and-statereflector</id><content type="html" xml:base="https://bitworking.org/news/2017/08/l-systems-with-redux-and-statereflector">&lt;p&gt;
  This is &lt;a
    href=&quot;/news/2017/08/d3-and-l-systems-with-redux-and-statereflector/news/2017/07/d3-and-l-systems-with-live-controls-and-redux&quot;&gt;D3
    and L-Systems with Redux and StateReflector&lt;/a&gt;, but now w/o the D3.js.
&lt;/p&gt;

&lt;p&gt;
  While &lt;a href=&quot;https://d3js.org/&quot;&gt;D3.js&lt;/a&gt; is fun, at this point it is a
  bit distracting, I'm more interested in Redux and data binding, so time to
  move back to just drawing static images on canvas.
&lt;/p&gt;

&lt;label for=length&gt;Length:&lt;/label&gt;
&lt;input type=range name=length id=length min=1 max=10 /&gt;
&lt;span style=&quot;padding: 0 10px;&quot; id=lengthDisplay&gt;&lt;/span&gt;
&lt;br&gt;
&lt;label for=angle&gt;Angle:&lt;/label&gt;
&lt;input type=range name=angle id=angle min=0.01 max=1 step=0.01 /&gt;
&lt;span style=&quot;padding: 0 10px;&quot; id=angleDisplay&gt;&lt;/span&gt;
&lt;br&gt;
&lt;canvas width=600 height=600&gt;&lt;/canvas&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
this.StateReflector = this.StateReflector || {};

(function(sr) {
  &quot;use strict&quot;;

  // A Promise that resolves when DOMContentLoaded has fired.
  sr.DomReady = new Promise(function(resolve, reject) {
    if (document.readyState != 'loading') {
      // If readyState is already past loading then
      // DOMContentLoaded has already fired, so just resolve.
      resolve();
    } else {
      document.addEventListener('DOMContentLoaded', resolve);
    }
  });

  // Namespace for utilities for working with URL query strings.
  sr.query = {};

  // fromObject takes an object and encodes it into a query string.
  //
  // The reverse of this function is toObject.
  sr.query.fromObject = function(o) {
    var ret = [];
    Object.keys(o).sort().forEach(function(key) {
      if (Array.isArray(o[key])) {
        o[key].forEach(function(value) {
          ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        })
      } else if (typeof(o[key]) == 'object') {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(sr.query.fromObject(o[key])));
      } else {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(o[key]));
      }
    });
    return ret.join('&amp;');
  }


  // toObject decodes a query string into an object
  // using the 'target' as a source for hinting on the types
  // of the values.
  //
  //   &quot;a=2&amp;b=true&quot;
  //
  // decodes to:
  //
  //   {
  //     a: 2,
  //     b: true,
  //   }
  //
  // When given a target of:
  //
  //   {
  //     a: 1.0,
  //     b: false,
  //   }
  //
  // Note that a target of {} would decode
  // the same query string into:
  //
  //   {
  //     a: &quot;2&quot;,
  //     b: &quot;true&quot;,
  //   }
  //
  // Only Number, String, Boolean, Object, and Array of String hints are supported.
  sr.query.toObject = function(s, target) {
    var target = target || {};
    var ret = {};
    var vars = s.split(&quot;&amp;&quot;);
    for (var i=0; i&lt;vars.length; i++) {
      var pair = vars[i].split(&quot;=&quot;, 2);
      if (pair.length == 2) {
        var key = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair[1]);
        if (target.hasOwnProperty(key)) {
          switch (typeof(target[key])) {
            case 'boolean':
              ret[key] = value==&quot;true&quot;;
              break;
            case 'number':
              ret[key] = Number(value);
              break;
            case 'object': // Arrays report as 'object' to typeof.
              if (Array.isArray(target[key])) {
                var r = ret[key] || [];
                r.push(value);
                ret[key] = r;
              } else {
                ret[key] = sr.query.toObject(value, target[key]);
              }
              break;
            case 'string':
              ret[key] = value;
              break;
            default:
              ret[key] = value;
          }
        } else {
          ret[key] = value;
        }
      }
    }
    return ret;
  }

  // Namespace for utilities for working with Objects.
  sr.object = {};

  // Returns true if a and b are equal, covers Boolean, Number, String and
  // Arrays and Objects.
  sr.object.equals = function(a, b) {
    if (typeof(a) != typeof(b)) {
      return false
    }
    var ta = typeof(a);
    if (ta == 'string' || ta == 'boolean' || ta == 'number') {
      return a === b
    }
    if (ta == 'object') {
      if (Array.isArray(ta)) {
        return JSON.stringify(a) == JSON.stringify(b)
      } else {
        return sr.query.fromObject(a) == sr.query.fromObject(b)
      }
    }
  }

  // Returns an object with only values that are in o that are different
  // from d.
  //
  // Only works shallowly, i.e. only diffs on the attributes of
  // o and d, and only for the types that sr.object.equals supports.
  sr.object.getDelta = function (o, d) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (!sr.object.equals(o[key], d[key])) {
        ret[key] = o[key];
      }
    });
    return ret;
  };

  // Returns a copy of object o with values from delta if they exist.
  sr.object.applyDelta = function (delta, o) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (delta.hasOwnProperty(key)) {
        ret[key] = JSON.parse(JSON.stringify(delta[key]));
      } else {
        ret[key] = JSON.parse(JSON.stringify(o[key]));
      }
    });
    return ret;
  };

  // Track the state of a page and reflect it to and from the URL.
  //
  // store - A Redux store.
  //        The state must be on Object and all the values in the Object
  //        must be Number, String, Boolean, Object, or Array of String.
  //        Doesn't handle NaN, null, or undefined.
  //
  // stateChange - A callback of the form function(state) that is called when
  //        state has been changed by a change in the URL, the return value
  //        should be appropriate for passing into store.dispatch();
  sr.stateReflector = function(store, stateChange) {
    var defaultState = store.getState();
    var lastState = store.getState();
    store.subscribe(function() {
      var state = store.getState();
      if (Object.keys(sr.object.getDelta(lastState, state)).length &gt; 0) {
        lastState = state;
        var q = sr.query.fromObject(sr.object.getDelta(state, defaultState));
        window.history.pushState(null, &quot;&quot;, window.location.origin + window.location.pathname + &quot;#&quot; +  q);
      }
    });

    // stateFromURL should be called when the URL has changed, it updates the state.
    var stateFromURL = function() {
      var delta = sr.query.toObject(window.location.hash.slice(1), defaultState);

      lastState = sr.object.applyDelta(delta, defaultState);
      store.dispatch(stateChange(lastState));
    }

    sr.DomReady.then(stateFromURL);

    // Every popstate event should also update the state.
    window.addEventListener('popstate', stateFromURL);
  }

})(this.StateReflector);
  &lt;/script&gt;

&lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
  (function () {
    var dup = (o) =&gt; JSON.parse(JSON.stringify(o));
    var $ = (id) =&gt; document.getElementById(id);

    var canvas = document.querySelector(&quot;canvas&quot;),
      ctx = canvas.getContext(&quot;2d&quot;),
      width = canvas.width,
      height = canvas.height;

    var rules = {
      &quot;X&quot;: &quot;F-[[X]+X]+F[+FX]-X&quot;,
      &quot;F&quot;: &quot;FF&quot;,
      &quot;+&quot;: &quot;+&quot;,
      &quot;-&quot;: &quot;-&quot;,
      &quot;[&quot;: &quot;[&quot;,
      &quot;]&quot;: &quot;]&quot;,
    }
    var E = (s) =&gt; s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot;;
    var L = E(E(E(E(E(&quot;X&quot;)))));

    function draw(x, y, len, angle) {
      var p = { x: x, y: y, a: 3 };
      var stack = [];
      ctx.beginPath()
      ctx.moveTo(p.x, p.y)
      L.split(&quot;&quot;).forEach(function(ch) {
        if (ch == &quot;F&quot;) {
          p.x += len*Math.sin(p.a);
          p.y += len*Math.cos(p.a);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
        } else if (ch == &quot;-&quot;) {
          p.a += angle;
        } else if (ch == &quot;+&quot;) {
          p.a -= angle;
        } else if (ch == &quot;[&quot;) {
          stack.push(dup(p));
        } else if (ch == &quot;]&quot;) {
          p = stack.pop();
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
        }
      })
    }

    var defaultState = {
      length: 7,
      angle: 0.4,
    };

    var updateState = (state = defaultState, action) =&gt; {
      if (action.type == &quot;@@redux/INIT&quot;) {
      } else if (action.type == &quot;REPLACE_ALL&quot;) {
        state = dup(action.value);
      } else {
        state = dup(state);
        state[action.type] = action.value;
      }
      return state;
    };

    var store = Redux.createStore(updateState);

    function render() {
      var state = store.getState();
      $('length').value = state.length;
      $('angle').value = state.angle;
      $('lengthDisplay').innerText = state.length;
      $('angleDisplay').innerText = state.angle;
      ctx.clearRect(0, 0, width, height);
      draw(width/2, height, state.length, state.angle);
    }

    store.subscribe(render);

    StateReflector.stateReflector(store, function(state) {
      return {type: &quot;REPLACE_ALL&quot;, value: state};
    });

    function dispatchFromEvent(id, event, xform) {
      $(id).addEventListener(event, function(e) {
        store.dispatch({
          type: e.target.id,
          value: xform(e),
        });
      });
    }

    dispatchFromEvent('length', 'input', (e) =&gt; +e.target.value);
    dispatchFromEvent('angle', 'input', (e) =&gt; +e.target.value);
  })();
&lt;/script&gt;
&lt;script src=&quot;https://gist.github.com/jcgregorio/7d83bcd9670575ec6c1f9bd682f7b24a.js&quot;&gt;&lt;/script&gt;</content><author><name></name></author><summary type="html">This is D3 and L-Systems with Redux and StateReflector, but now w/o the D3.js.</summary></entry><entry><title type="html">D3 and L-Systems with Redux and StateReflector</title><link href="https://bitworking.org/news/2017/08/d3-and-l-systems-with-redux-and-statereflector" rel="alternate" type="text/html" title="D3 and L-Systems with Redux and StateReflector" /><published>2017-08-05T00:00:00-04:00</published><updated>2017-08-05T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/08/d3-and-l-systems-with-redux-and-statereflector</id><content type="html" xml:base="https://bitworking.org/news/2017/08/d3-and-l-systems-with-redux-and-statereflector">&lt;p&gt;
  This is &lt;a href=&quot;/news/2017/07/d3-and-l-systems-with-live-controls-and-redux&quot;&gt;D3
    and L-Systems with live controls and Redux&lt;/a&gt;, but now state is reflected
  into the &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;URL
    Fragment&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
  The syncing is two way, that is, changes to the state of the controls are
  reflected into the URL Fragment, and changes to the fragment are reflected
  into the state of the controls, so every change give you a permalink to
  that state, and browser history navigation works.
&lt;/p&gt;

  &lt;label for=&quot;linkDistance&quot;&gt;Link Distance:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkDistance&quot; id=&quot;linkDistance&quot; min=1 max=10 /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkDistanceDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;linkStrength&quot;&gt;Link Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkStrength&quot; id=&quot;linkStrength&quot; min=0.01 max=4 step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;chargeStrength&quot;&gt;Charge Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;chargeStrength&quot; id=&quot;chargeStrength&quot; min=&quot;-10&quot; max=&quot;-0.01&quot; step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=chargeStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
this.StateReflector = this.StateReflector || {};

(function(sr) {
  &quot;use strict&quot;;

  // A Promise that resolves when DOMContentLoaded has fired.
  sr.DomReady = new Promise(function(resolve, reject) {
    if (document.readyState != 'loading') {
      // If readyState is already past loading then
      // DOMContentLoaded has already fired, so just resolve.
      resolve();
    } else {
      document.addEventListener('DOMContentLoaded', resolve);
    }
  });

  // Namespace for utilities for working with URL query strings.
  sr.query = {};

  // fromObject takes an object and encodes it into a query string.
  //
  // The reverse of this function is toObject.
  sr.query.fromObject = function(o) {
    var ret = [];
    Object.keys(o).sort().forEach(function(key) {
      if (Array.isArray(o[key])) {
        o[key].forEach(function(value) {
          ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        })
      } else if (typeof(o[key]) == 'object') {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(sr.query.fromObject(o[key])));
      } else {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(o[key]));
      }
    });
    return ret.join('&amp;');
  }


  // toObject decodes a query string into an object
  // using the 'target' as a source for hinting on the types
  // of the values.
  //
  //   &quot;a=2&amp;b=true&quot;
  //
  // decodes to:
  //
  //   {
  //     a: 2,
  //     b: true,
  //   }
  //
  // When given a target of:
  //
  //   {
  //     a: 1.0,
  //     b: false,
  //   }
  //
  // Note that a target of {} would decode
  // the same query string into:
  //
  //   {
  //     a: &quot;2&quot;,
  //     b: &quot;true&quot;,
  //   }
  //
  // Only Number, String, Boolean, Object, and Array of String hints are supported.
  sr.query.toObject = function(s, target) {
    var target = target || {};
    var ret = {};
    var vars = s.split(&quot;&amp;&quot;);
    for (var i=0; i&lt;vars.length; i++) {
      var pair = vars[i].split(&quot;=&quot;, 2);
      if (pair.length == 2) {
        var key = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair[1]);
        if (target.hasOwnProperty(key)) {
          switch (typeof(target[key])) {
            case 'boolean':
              ret[key] = value==&quot;true&quot;;
              break;
            case 'number':
              ret[key] = Number(value);
              break;
            case 'object': // Arrays report as 'object' to typeof.
              if (Array.isArray(target[key])) {
                var r = ret[key] || [];
                r.push(value);
                ret[key] = r;
              } else {
                ret[key] = sr.query.toObject(value, target[key]);
              }
              break;
            case 'string':
              ret[key] = value;
              break;
            default:
              ret[key] = value;
          }
        } else {
          ret[key] = value;
        }
      }
    }
    return ret;
  }

  // Namespace for utilities for working with Objects.
  sr.object = {};

  // Returns true if a and b are equal, covers Boolean, Number, String and
  // Arrays and Objects.
  sr.object.equals = function(a, b) {
    if (typeof(a) != typeof(b)) {
      return false
    }
    var ta = typeof(a);
    if (ta == 'string' || ta == 'boolean' || ta == 'number') {
      return a === b
    }
    if (ta == 'object') {
      if (Array.isArray(ta)) {
        return JSON.stringify(a) == JSON.stringify(b)
      } else {
        return sr.query.fromObject(a) == sr.query.fromObject(b)
      }
    }
  }

  // Returns an object with only values that are in o that are different
  // from d.
  //
  // Only works shallowly, i.e. only diffs on the attributes of
  // o and d, and only for the types that sr.object.equals supports.
  sr.object.getDelta = function (o, d) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (!sr.object.equals(o[key], d[key])) {
        ret[key] = o[key];
      }
    });
    return ret;
  };

  // Returns a copy of object o with values from delta if they exist.
  sr.object.applyDelta = function (delta, o) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (delta.hasOwnProperty(key)) {
        ret[key] = JSON.parse(JSON.stringify(delta[key]));
      } else {
        ret[key] = JSON.parse(JSON.stringify(o[key]));
      }
    });
    return ret;
  };

  // Track the state of a page and reflect it to and from the URL.
  //
  // store - A Redux store.
  //        The state must be on Object and all the values in the Object
  //        must be Number, String, Boolean, Object, or Array of String.
  //        Doesn't handle NaN, null, or undefined.
  //
  // stateChange - A callback of the form function(state) that is called when
  //        state has been changed by a change in the URL, the return value
  //        should be appropriate for passing into store.dispatch();
  sr.stateReflector = function(store, stateChange) {
    var defaultState = store.getState();
    var lastState = store.getState();
    store.subscribe(function() {
      var state = store.getState();
      if (Object.keys(sr.object.getDelta(lastState, state)).length &gt; 0) {
        lastState = state;
        var q = sr.query.fromObject(sr.object.getDelta(state, defaultState));
        window.history.pushState(null, &quot;&quot;, window.location.origin + window.location.pathname + &quot;#&quot; +  q);
      }
    });

    // stateFromURL should be called when the URL has changed, it updates the state.
    var stateFromURL = function() {
      var delta = sr.query.toObject(window.location.hash.slice(1), defaultState);

      lastState = sr.object.applyDelta(delta, defaultState);
      store.dispatch(stateChange(lastState));
    }

    sr.DomReady.then(stateFromURL);

    // Every popstate event should also update the state.
    window.addEventListener('popstate', stateFromURL);
  }

})(this.StateReflector);
  &lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var dup = (o) =&gt; JSON.parse(JSON.stringify(o));
      var $ = (id) =&gt; document.getElementById(id);

      var defaultState = {
        linkStrength: 0.5,
        linkDistance: 3,
        chargeStrength: -1,
      };

      var linkForce = d3.forceLink().iterations(5).id(function(d) { return d.id; });
      var charge = d3.forceManyBody();
      var simulation = d3.forceSimulation()
          .force(&quot;link&quot;, linkForce)
          .force(&quot;charge&quot;, charge)
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2));

      var updateState = (state = defaultState, action) =&gt; {
        if (action.type == &quot;@@redux/INIT&quot;) {
        } else if (action.type == &quot;REPLACE_ALL&quot;) { // This is new.
          state = dup(action.value);
        } else {
            state = dup(state);
          state[action.type] = action.value;
        }
        return state;
      }

      var store = Redux.createStore(updateState);

      function render() {
        var state = store.getState();
        $('linkStrength').value = state.linkStrength;
        $('linkDistance').value = state.linkDistance;
        $('chargeStrength').value = state.chargeStrength;
        $('linkStrengthDisplay').innerText = state.linkStrength;
        $('linkDistanceDisplay').innerText = state.linkDistance;
        $('chargeStrengthDisplay').innerText = state.chargeStrength;
        linkForce.distance(state.linkDistance).strength(state.linkStrength);
        charge.strength(state.chargeStrength);
        simulation.alphaTarget(0.1).restart();
      }

      store.subscribe(render);

      // This is new.
      StateReflector.stateReflector(store, function(state) {
        return {type: &quot;REPLACE_ALL&quot;, value: state};
      });
      render();

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

      function dispatchFromEvent(id, event, xform) {
        $(id).addEventListener(event, function(e) {
          store.dispatch({
            type: e.target.id,
            value: xform(e),
          });
        });
      }

      dispatchFromEvent('linkDistance', 'input', (e) =&gt; +e.target.value);
      dispatchFromEvent('linkStrength', 'input', (e) =&gt; Math.abs(+e.target.value));
      dispatchFromEvent('chargeStrength', 'input', (e) =&gt; -Math.abs(+e.target.value));

    })();
  &lt;/script&gt;

  &lt;p&gt;
    There are only two small changes from the previous code, the addition of a
    &lt;a
      href=&quot;https://gist.github.com/jcgregorio/d3fae4dd7ebc3617cd669a855ae4ad9a#file-l-system-js-L58&quot;&gt;
      new action &quot;REPLACE_ALL&quot; that the store understands&lt;/a&gt;, and then 
    &lt;a
      href=&quot;https://gist.github.com/jcgregorio/d3fae4dd7ebc3617cd669a855ae4ad9a#file-l-system-js-L84&quot;&gt;the call
      to initialize StateReflector&lt;/a&gt;.
  &lt;/p&gt;

  &lt;p&gt;
    The StateReflector is extraced from &lt;a
      href=&quot;https://github.com/google/skia-buildbot/blob/32ea496dbdc5865230d25073ac44f27ce16bb735/res/js/common.js#L709&quot;&gt;this
      code&lt;/a&gt; from the &lt;a href=&quot;https://skia.org&quot;&gt;Skia&lt;/a&gt; Infrastructure codebase. The URL Fragment will
    only contain information that's required, this is, if a value in the state
    is unchanged from the default or initial value, then that value won't
    appear in the URL Fragment.
  &lt;/p&gt;
  &lt;p&gt;
    The pairing with Redux makes this much nicer. In all of our (Skia Infra) current code
    we don't use Redux, and so for StateReflector to work it needs to monitor
    the internal state of the page which is does using a 100ms timer.
    While the overhead is very low, having a non-polling solution is
    obviously better.
  &lt;/p&gt;
  &lt;p&gt;
    The StateReflector code is also modified from the original so that it
    store the state in the URL Fragment, while the original code stores the
    state in the URL Query. It's probably worth making that a configuration
    option to stateReflector.
  &lt;/p&gt;
  &lt;p&gt;
    If StateReflector looks useful to anyone let me know in the comments
    and I'll stand up a repo and port the tests over too.
  &lt;/p&gt;
  &lt;script
    src=&quot;https://gist.github.com/jcgregorio/d3fae4dd7ebc3617cd669a855ae4ad9a.js&quot;&gt;&lt;/script&gt;</content><author><name></name></author><summary type="html">This is D3 and L-Systems with live controls and Redux, but now state is reflected into the URL Fragment.</summary></entry><entry><title type="html">What a bold platform really looks like.</title><link href="https://bitworking.org/news/2017/07/what-a-bold-platform-really-looks-like" rel="alternate" type="text/html" title="What a bold platform really looks like." /><published>2017-07-29T00:00:00-04:00</published><updated>2017-07-29T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/what-a-bold-platform-really-looks-like</id><content type="html" xml:base="https://bitworking.org/news/2017/07/what-a-bold-platform-really-looks-like">&lt;p&gt;&lt;a href=&quot;http://www.huffingtonpost.com/entry/chuck-schumer-single-payer_us_5974b05be4b00e4363e0164e&quot;&gt;Chuck Schumer Says Senate Democrats Are Open To Single-Payer Health Care&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‚ÄúWe‚Äôre going to look at broader things [for health care],‚Äù he said.
‚ÄúSingle-payer is one of them.. Many things are on the table. Medicare for
people above 55 is on the table. A buy-in to Medicare is on the table.
Buy-in to Medicaid is on the table.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yeah, &lt;strong&gt;bold&lt;/strong&gt; leadership always comes from phrases like ‚Äúon the table‚Äù. Don‚Äôt
you remember &lt;a href=&quot;http://www.telegraph.co.uk/news/winston-churchill/11366880/Winston-Churchills-10-most-important-speeches.html&quot;&gt;Churchill‚Äôs famous
speech&lt;/a&gt;?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Going to the end is on the table. Fighting in France is on the table, fighting on the
seas and oceans is a possibility, fighting with growing confidence and growing strength
in the air is something we‚Äôre certainly willing to talk about.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The leadership on display here is just pathetic.&lt;/p&gt;

&lt;p&gt;A simple bold platform is very easy to state, and also one that‚Äôs easy to
support. Additionally, if you keep it direct you can more easily construct
radical arguments to move the &lt;a href=&quot;https://en.wikipedia.org/wiki/Overton_window&quot;&gt;Overton&lt;/a&gt; window.
For example, on just three issues, the platform could be boldly and simply
stated, and the Overton postions below are the ones you get some people to
state, so that the platform position looks like a reasonable compromise.&lt;/p&gt;

&lt;h2 id=&quot;healthcare&quot;&gt;Healthcare&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Platform&lt;/strong&gt;: Medicare for all.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Overton&lt;/strong&gt;: Let‚Äôs nationalize hospitals and shut down the health insurance industry.&lt;/p&gt;

&lt;h2 id=&quot;education&quot;&gt;Education&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Platform&lt;/strong&gt;: Free college education (up to a bachelor‚Äôs degree).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Overton&lt;/strong&gt;: Let‚Äôs nationalize the education system and extend mandatory education from a high school diploma to a bachelor‚Äôs degree.&lt;/p&gt;

&lt;h2 id=&quot;taxes&quot;&gt;Taxes&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Platform&lt;/strong&gt;: Return to a progressive tax system where the wealthy pay their
fair share and loopholes are closed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Overton&lt;/strong&gt;: A top marginal income tax rate of 90%.&lt;/p&gt;

&lt;p&gt;Now aren‚Äôt those a lot more appealing than the mealy mouthed alternatives?&lt;/p&gt;</content><author><name></name></author><summary type="html">Chuck Schumer Says Senate Democrats Are Open To Single-Payer Health Care</summary></entry><entry><title type="html">D3 and L-Systems with live controls and Redux</title><link href="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls-and-redux" rel="alternate" type="text/html" title="D3 and L-Systems with live controls and Redux" /><published>2017-07-23T00:00:00-04:00</published><updated>2017-07-23T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls-and-redux</id><content type="html" xml:base="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls-and-redux">&lt;p&gt;
  This is just &lt;a href=&quot;/news/2017/07/d3-and-l-systems-with-live-controls&quot;&gt;D3
    and L-Systems with live controls&lt;/a&gt;, but now state is managed by &lt;a
    href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;. Oh, and also arrow functions,
  because &lt;a href=&quot;https://caniuse.com/#feat=arrow-functions&quot;&gt;they're
    available everywhere I care about&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
  I've been reading about Redux and wanted to try it out. It seems
  nice, as it forced me to consolidate everything about page state, which
  caused me to clean up the code quite a bit. I like that in a tool. It's
  also the reason I like Go and way it handles 'error', it forces me to think
  about the not-happy-path as opposed to the happy-path, which always makes
  my code better.
&lt;/p&gt;
&lt;p&gt;
  I think it's interesting that there isn't a library to map the state into
  the URL, at least I couldn't find anything that wasn't either a React based
  solution or a full blown routing package. I've got some &lt;a
    href=&quot;https://github.com/google/skia-buildbot/blob/32ea496dbdc5865230d25073ac44f27ce16bb735/res/js/common.js#L720&quot;&gt;code that already
    does that&lt;/a&gt;, I wonder if it would be useful to break that out as its own
  library.
&lt;/p&gt;

  &lt;label for=&quot;linkDistance&quot;&gt;Link Distance:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkDistance&quot; id=&quot;linkDistance&quot; min=1 max=10 /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkDistanceDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;linkStrength&quot;&gt;Link Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkStrength&quot; id=&quot;linkStrength&quot; min=0.01 max=4 step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;chargeStrength&quot;&gt;Charge Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;chargeStrength&quot; id=&quot;chargeStrength&quot; min=&quot;-10&quot; max=&quot;-0.01&quot; step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=chargeStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var dup = (o) =&gt; JSON.parse(JSON.stringify(o));
      var $ = (id) =&gt; document.getElementById(id);

      var defaultState = {
        linkStrength: 0.5,
        linkDistance: 3,
        chargeStrength: -1,
      };

      var linkForce = d3.forceLink().iterations(5).id(function(d) { return d.id; });
      var charge = d3.forceManyBody();
      var simulation = d3.forceSimulation()
          .force(&quot;link&quot;, linkForce)
          .force(&quot;charge&quot;, charge)
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2));

      var updateState = (state = defaultState, action) =&gt; {
        state = dup(state);
        state[action.type] = action.value;
        return state;
      }

      var store = Redux.createStore(updateState);

      function render() {
        var state = store.getState();
        $('linkStrength').value = state.linkStrength;
        $('linkDistance').value = state.linkDistance;
        $('chargeStrength').value = state.chargeStrength;
        $('linkStrengthDisplay').innerText = state.linkStrength;
        $('linkDistanceDisplay').innerText = state.linkDistance;
        $('chargeStrengthDisplay').innerText = state.chargeStrength;
        linkForce.distance(state.linkDistance).strength(state.linkStrength);
        charge.strength(state.chargeStrength);
        simulation.alphaTarget(0.1).restart();
      }

      store.subscribe(render);
      render();

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

      function dispatchFromEvent(id, event, xform) {
        $(id).addEventListener(event, function(e) {
          store.dispatch({
            type: e.target.id,
            value: xform(e),
          });
        });
      }

      dispatchFromEvent('linkDistance', 'input', (e) =&gt; +e.target.value);
      dispatchFromEvent('linkStrength', 'input', (e) =&gt; Math.abs(+e.target.value));
      dispatchFromEvent('chargeStrength', 'input', (e) =&gt; -Math.abs(+e.target.value));

    })();
  &lt;/script&gt;

  &lt;pre&gt;&lt;code id=code&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    document.getElementById('code').textContent = document.getElementById('src').textContent;
  &lt;/script&gt;</content><author><name></name></author><summary type="html">This is just D3 and L-Systems with live controls, but now state is managed by Redux. Oh, and also arrow functions, because they're available everywhere I care about.</summary></entry><entry><title type="html">D3 and L-Systems with live controls</title><link href="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls" rel="alternate" type="text/html" title="D3 and L-Systems with live controls" /><published>2017-07-22T00:00:00-04:00</published><updated>2017-07-22T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls</id><content type="html" xml:base="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls">&lt;p&gt;
  An &lt;a href=&quot;/news/2017/07/d3-and-l-systems&quot;&gt;L-System fed into d3-force&lt;/a&gt;, but now with controls that allow you to
  change some of the simulation parameters.
&lt;/p&gt;

  &lt;label for=&quot;linkDistance&quot;&gt;Link Distance:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkDistance&quot; id=&quot;linkDistance&quot; min=1 max=10 value=&quot;3&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkDistanceDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;linkStrength&quot;&gt;Link Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkStrength&quot; id=&quot;linkStrength&quot; value=&quot;0.5&quot; min=0.01 max=4 step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;chargeStrength&quot;&gt;Charge Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;chargeStrength&quot; id=&quot;chargeStrength&quot; value=&quot;-1&quot; min=&quot;-10&quot; max=&quot;-0.01&quot; step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=chargeStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var linkDistance = 3;
      var linkStrength = 0.5;
      var linkForce = d3.forceLink().distance(linkDistance).strength(linkStrength).iterations(5).id(function(d) { return d.id; });
      var chargeStrength = -1;
      var charge = d3.forceManyBody().strength(chargeStrength);
      simulation = d3.forceSimulation()
          .force(&quot;link&quot;, linkForce)
          .force(&quot;charge&quot;, charge)
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2))

      function updateSimulation() {
        linkForce.distance(linkDistance).strength(linkStrength);
        charge.strength(chargeStrength);
        simulation.alphaTarget(0.1).restart();
      }

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

      document.getElementById('linkDistance').addEventListener('input', function(e) {
        linkDistance = +e.target.value;
        document.getElementById('linkDistanceDisplay').innerText = linkDistance;
        updateSimulation();
      });

      document.getElementById('linkStrength').addEventListener('input', function(e) {
        linkStrength = +e.target.value;
        if (linkStrength &lt; 0) {
          linkStrength = -linkStrength;
          e.target.value = linkStrength;
        }
        document.getElementById('linkStrengthDisplay').innerText = linkStrength;
        updateSimulation();
      });

      document.getElementById('chargeStrength').addEventListener('input', function(e) {
        chargeStrength = +e.target.value;
        if (chargeStrength &gt; 0) {
          chargeStrength = -chargeStrength;
          e.target.value = chargeStrength;
        }
        document.getElementById('chargeStrengthDisplay').innerText = chargeStrength;
        updateSimulation();
      });

    })();
  &lt;/script&gt;

  &lt;pre&gt;&lt;code id=code&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    document.getElementById('code').textContent = document.getElementById('src').textContent;
  &lt;/script&gt;</content><author><name></name></author><summary type="html">An L-System fed into d3-force, but now with controls that allow you to change some of the simulation parameters.</summary></entry><entry><title type="html">D3 and L-Systems</title><link href="https://bitworking.org/news/2017/07/d3-and-l-systems" rel="alternate" type="text/html" title="D3 and L-Systems" /><published>2017-07-20T00:00:00-04:00</published><updated>2017-07-20T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/d3-and-l-systems</id><content type="html" xml:base="https://bitworking.org/news/2017/07/d3-and-l-systems">&lt;p&gt;
  So we know &lt;a
    href=&quot;https://bitworking.org/news/2017/07/l-systems&quot;&gt;L-Systems&lt;/a&gt; are
  fun. What if we let &lt;a href=&quot;https://github.com/d3/d3-force&quot;&gt;d3-force&lt;/a&gt;
  layout the nodes of the L-System?
&lt;/p&gt;

  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var simulation = d3.forceSimulation()
          .force(&quot;link&quot;, d3.forceLink().distance(3).strength(0.5).iterations(2).id(function(d) { return d.id; }))
          .force(&quot;charge&quot;, d3.forceManyBody().strength(-1))
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2));

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

    })();
  &lt;/script&gt;

  &lt;pre&gt;&lt;code id=code&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    document.getElementById('code').textContent = document.getElementById('src').textContent;
  &lt;/script&gt;</content><author><name></name></author><summary type="html">So we know L-Systems are fun. What if we let d3-force layout the nodes of the L-System?</summary></entry><entry><title type="html">Data binding and JS frameworks</title><link href="https://bitworking.org/news/2017/07/data-binding-and-js-frameworks" rel="alternate" type="text/html" title="Data binding and JS frameworks" /><published>2017-07-16T00:00:00-04:00</published><updated>2017-07-16T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/data-binding-and-js-frameworks</id><content type="html" xml:base="https://bitworking.org/news/2017/07/data-binding-and-js-frameworks">&lt;p&gt;It was over three years ago that I wrote
&lt;a href=&quot;https://bitworking.org/news/2014/05/zero_framework_manifesto&quot;&gt;No more JS frameworks&lt;/a&gt;, at which time
I was roundly criticized for not understanding that data binding could only be
done via JS framework, the two were inextricably linked, and only 2-way data
binding would do, as one way data binding was for weak-minded fools who
weren‚Äôt building real applications. You can find the comments on HN yourself,
I don‚Äôt link to that cesspool.&lt;/p&gt;

&lt;p&gt;So, in that context, it was funny to read
&lt;a href=&quot;https://medium.com/@chriscordle/why-angular-2-4-is-too-little-too-late-ea86d7fa0bae&quot;&gt;Why Angular 2/4 Is Too Little, Too Late&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Two way data-binding was a feature in 2013 and Facebook said it was a &lt;strong&gt;bug&lt;/strong&gt;.
It turns out they were &lt;em&gt;right&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The post goes on to explain how the ‚Äúindustry settled on
&lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;‚Äù, which is nice to see that the functionality
is delivered as a standalone library, and &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/LICENSE.md&quot;&gt;MIT Licensed&lt;/a&gt;,
because &lt;a href=&quot;https://issues.apache.org/jira/browse/LEGAL-303&quot;&gt;licenses matter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My only concern is that I believe I too work in the industry and I‚Äôve spent
the last three years delivering applications using
&lt;a href=&quot;https://www.polymer-project.org/&quot;&gt;Polymer&lt;/a&gt;, so I guess I‚Äôm not ‚Äúsettled‚Äù?&lt;/p&gt;</content><author><name></name></author><summary type="html">It was over three years ago that I wrote No more JS frameworks, at which time I was roundly criticized for not understanding that data binding could only be done via JS framework, the two were inextricably linked, and only 2-way data binding would do, as one way data binding was for weak-minded fools who weren‚Äôt building real applications. You can find the comments on HN yourself, I don‚Äôt link to that cesspool.</summary></entry></feed>