#!/bin/bash
#
#    'idnits' looks for violations of Section 2.1 and 2.2 of the
#    requirements listed on http://www.ietf.org/ID-Checklist.html

# Copyright:
#  -----------------------------------------------------------------
#
#  Copyright 2002-2004 Henrik Levkowetz
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  -----------------------------------------------------------------

version="1.102";
progdate="";
export LC_ALL=C

# ----------------------------------------------------------------------
# Utility to find an executable
# ----------------------------------------------------------------------

lookfor() {
    default="$1"; shift
    for b in "$@"; do
	found=$(type -p "$b" 2>/dev/null)
	if [ -n "$found" ]; then
	    if [ -x "$found" ]; then
		echo "$found"
		return
	    fi
	fi
    done
    echo "$default"
}

AWK=$(lookfor gawk $AWK gawk nawk mawk awk)

# ----------------------------------------------------------------------
# Strip headers and footers, end-of-line whitespace and \r (CR)
# ----------------------------------------------------------------------
strip() {
  $AWK '
BEGIN				{
				  longestpage = 1;
				  textcolumn=8; # initialise minimum indentation we found
				}
				{ gsub(/\r/, ""); }
				{ gsub(/[ \t]+$/, ""); }
				{ pagelength++; }

/\[?[Pp]age [0-9ivx]+\]?[ \t\f]*$/	{
				    match($0, /[Pp]age [0-9ivx]+/);
				    num = substr($0, RSTART+5, RLENGTH-5);
				    if (num+0 > maxpage) maxpage = num+0;
				    pagecount++;
				    countedpage=1;
				    if (pagelength > 58) longpagecount++;
				    if (maxlength < pagelength) {
					maxlength = pagelength;
					longestpage = num;
				    }
				    pagelength = 0;
				}
/\f/				{ newpage=1;
				  ffcount++;
				  if (pagelength > 58) longpagecount++;
				  if (! countedpage) {
				      pagecount++;
				      countedpage=0;
				  }
				  if (maxlength < pagelength) {
				      maxlength = pagelength;
				      longestpage = pagecount;
				  }
				  pagelength=1;
				  next;
				}
/\f$/				{
				    # a form feed followed by a \n does not contribute to the
				    # line count.  (But a \f followed by something else does.)
				    pagelength--;
				}
/\[?[Pp]age [0-9ivx]+\]?[ \t\f]*$/	{ next; }

/^ *Internet.Draft.+[12][0-9][0-9][0-9] *$/	{ newpage=1; next; }
/^ *INTERNET.DRAFT.+[12][0-9][0-9][0-9] *$/	{ newpage=1; next; }
/^ *Draft.+[12][0-9][0-9][0-9] *$/		{ newpage=1; next; }
/^RFC.+[0-9]+$/					{ newpage=1; next; }
/^draft-[-a-z0-9_.]+.*[0-9][0-9][0-9][0-9]$/	{ newpage=1; next; }
/(Jan|Feb|Mar|March|Apr|April|May|Jun|June|Jul|July|Aug|Sep|Oct|Nov|Dec) (19[89][0-9]|20[0-9][0-9]) *$/ && pagelength < 3  { newpage=1; next; }
newpage && $0 ~ /^ *draft-[-a-z0-9_.]+ *$/ { newpage=1; next; }

/^[^ \t]/			{ sentence=1; }
/[^ \t]/			{
				   if (newpage) {
				      if (sentence) {
					 outline++; print "";
				      }
				   } else {
				      if (haveblank) {
					  outline++; print "";
				      }
				   }
				   haveblank=0;
				   sentence=0;
				   newpage=0;

				   line = $0;
				   sub(/^ *\t/, "        ", line);
				   thiscolumn = match(line, /[^ ]/);
				   if (thiscolumn && thiscolumn < textcolumn) textcolumn = thiscolumn;
				}
/[.:][ \t]*$/			{ sentence=1; }
/^[ \t]*$/			{ haveblank=1; next; }
				{ outline++; print; }
END				{
				  if (pagecount == 0) pagecount = 1;
				  if (longpagecount == 0 && pagelength > 58) longpagecount++;

				  print  "";
				  printf "-+- Pagecount: %d -+-\n", (pagecount > maxpage ? pagecount : maxpage);
				  printf "-+- Maxpagelength: %d -+-\n", (pagelength > maxlength ? pagelength : maxlength);
				  printf "-+- Longpagecount: %d -+-\n", longpagecount;
				  printf "-+- Longestpage: %d -+-\n", longestpage;
				  printf "-+- Formfeedcount: %d -+-\n", ffcount;
				}
' $1
}

tmpfile() {
    prefix=$(basename $0)
    for tmpdir in $TMPDIR $TMP $TEMP /tmp .; do
	if [ -d $tmpdir -a -w $tmpdir ]; then
	    tmpfn=$tmpdir/$prefix-$$.tmp
	    echo $tmpfn
	    exit
	fi
    done
    if [ -z $tmpfn ]; then
	echo "Can't find any writable directory for temporary files; this won't work..." > /dev/stderr
    fi
}

checknits() {

    program=$(tmpfile)

    cat << 'EOF' > $program

BEGIN {
    option_verbose = 0;
    option_warn = 1;

    split(ENVIRON["CHECKNITS"], argv);

    columns = ENVIRON["COLUMNS"];
    if (! columns ) columns = 78;
    if (columns > 80) columns = 80;
    if (columns < 16) columns = 16;
    if (columns < 73) bpcols = columns; else bpcols = 73;

    indentation = 8;

    for (i in argv) {
	# Deprecated
	if (argv[i] == "--rfc3667") {
	    printf "\nOption %s does nothing any more\n", argv[i];
	    argv[i] = "";
	}
	if (argv[i] == "--no3667") {
	    printf "\nOption %s does nothing any more\n", argv[i];
	    argv[i] = "";
	}
	if (argv[i] == "--rfc2026") {
	    printf "\nOption %s does nothing any more\n", argv[i];
	    argv[i] = "";
	}
	if (argv[i] == "--nowarn") {
	    option_warn = 0;
	    argv[i] = "";
	}
	if (argv[i] == "--filename") {
	    option_filename = argv[i+1];
	    argv[i] = "";
	    argv[i+1] = "";
	}
	if (argv[i] == "--debug") {
	    option_debug = 1;
	    argv[i] = "";
	}
	if (argv[i] == "--nitcount") {
	    option_nitcount = 1;
	    argv[i] = "";
	}
	if (argv[i] == "--pass1") {
	    option_pass1 = 1;
	    argv[i] = "";
	}
	if (argv[i] == "--verbose") {
	    option_verbose++;
	    argv[i] = "";
	}
	if (argv[i] == "--list-matches") {
	    option_list_matches = 1;
	    argv[i] = "";
	}
	if (argv[i] == "--year") {
	    option_year = argv[i+1];
	    argv[i] = "";
	    argv[i+1] = "";
	}
	if (argv[i] == "--") {
	    argv[i] = "";
	}
	if (argv[i] ~ "^-.+") {
	    printf "\nUnknown option: %s\n\n", argv[i];
	    usage();
	    exit 1;
	}
	if (argv[i] ~ "^--.+") {
	    printf "\nUnknown option: %s\n\n", argv[i];
	    usage();
	    exit 1;
	}
    }
    option_pass2 = ! option_pass1;

    split("SOH STX ETX EOT ENQ ACK BEL BS TAB LF VT FF CR SO SI DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM SUB ESC FS GS RS US", controlchar)
    for (i in controlchar) {
	controlchar[sprintf("%c",i+0)] = controlchar[i];
	del controlchar[i];
    }

    # Extract a list of hyphenated words from the document, and build an array of valid fragments
    if ( length(option_filename) ) {
	cmd = sprintf("cat %s | sed 's/[^A-Za-z0-9_-]/\\n/g' | sort | uniq | egrep -- '-' | egrep -v -- '-$' | egrep '^[A-Za-z0-9]'", option_filename )
	while ( cmd | getline > 0 ) {
	    word = $0
	    frag = ""
	    for (;;) {
		if ( length(word) == 0 ) break

		pos = index(word, "-")
		if ( pos == 0 ) break

	        frag = frag substr(word, 1, pos )
	        hyphenfrags[frag]
		has_hyphenlist = 1
		word = substr(word, pos+1)
	    }
	}
    }

    # get current year
    if ( option_year > 1990 ) {
	year = option_year;
    } else if ( "date +'%Y'" | getline year <= 0 ) {
	year = "[0-9]+"
    }

    has[""];		# make sure this exists as a global variable here

    # ------------------------------------------------------------------
    #   3978 and 3979 section texts
    #

    bp["rfc3667_3_claim"] = "This document is an Internet-Draft and is subject to all provisions " \
		      "of (S|s)ection 3 of( | \\])RFC( |.?)(3667|3667\\])\\.$";

    bp["rfc3667_5_1"] = "By submitting this Internet-Draft, (I|we) certify that any applicable " \
                      "patent or other IPR claims of which (I am|we are) aware have been disclosed,( or " \
                      "will be disclosed,)? and any of which (I|we) become aware will be disclosed, " \
		      "in accordance with RFC 3668.$";

    bp["rfc3978_5_1"] = "By submitting this Internet-Draft, each author represents that any " \
		      "applicable patent or other IPR claims of which he or she is aware " \
		      "have been or will be disclosed, and any of which he or she becomes " \
		      "aware will be disclosed, in accordance with Section 6 of BCP 79.$";

    bp["rfc3978_5_1_a"] = "By submitting this Internet-Draft, (each|the) author represents that any " \
		      "applicable patent or other IPR claims of which (he or she|he|she) is aware " \
		      "have been or will be disclosed, and any of which (he or she|he|she) becomes? " \
		      "aware will be disclosed, in accordance with( (S|s)ection 6 of)? (BCP 79|RFC 3979|RFC 3668).$";

    bp["rfc3978_5_2a"] = "This document may not be modified, and derivative works of it may " \
                      "not be created, except to publish it as an RFC and to translate it " \
                      "into languages other than English.$";

    bp["rfc3978_5_2ax"] = "This document may not be modified, and derivative works of it may " \
                      "not be created, except to publish it as an RFC and to translate it " \
                      "into languages other than English other than to extract section " \
                      "[0-9.]+ as-is for separate use.$";

    bp["rfc3978_5_2b"] = "This document may not be modified, and derivative works of it may " \
                      "not be created.$";

    bp["rfc3978_5_2bx"] = "This document may not be modified, and derivative works of it may " \
                      "not be created other than to extract section [0-9.]+ as-is for separate use.$";

    bp["rfc3978_5_3"] = "This document may only be posted in an Internet-Draft.$";

    bp["rfc3978_5_4_p1"] = "Copyright \\(C\\) The Internet Society \\(?[0-9]+\\)?.$"

    bp["rfc3978_5_4_p1_now"] = sprintf("Copyright \\(C\\) The Internet Society \\(?%s\\)?", year);

    bp["rfc3978_5_4_p2"] = "This document is subject to the rights, licenses and restrictions contained in BCP " \
                      "78, and except as set forth therein, the authors retain all their rights.$";

    bp["rfc3978_5_5"] = "This document and the information contained herein are provided " \
                      "on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE " \
                      "REPRESENTS OR IS SPONSORED BY \\(IF ANY\\), THE INTERNET SOCIETY AND " \
                      "THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, " \
                      "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT " \
                      "THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR " \
                      "ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A " \
                      "PARTICULAR PURPOSE.$";

    bp["rfc3979_5_p1"] = "The IETF takes no position regarding the validity or scope of any " \
                      "Intellectual Property Rights or other rights that might be claimed " \
                      "to pertain to the implementation or use of the technology " \
                      "described in this document or the extent to which any license " \
                      "under such rights might or might not be available; nor does it " \
                      "represent that it has made any independent effort to identify any " \
                      "such rights.  Information on the procedures with respect to rights " \
                      "in RFC documents can be found in BCP 78 and BCP 79.$";

    bp["rfc3979_5_p2"] = "Copies of IPR disclosures made to the IETF Secretariat and any " \
                      "assurances of licenses to be made available, or the result of an " \
                      "attempt made to obtain a general license or permission for the use " \
                      "of such proprietary rights by implementers or users of this " \
                      "specification can be obtained from the IETF on-line IPR repository " \
                      "at http://www.ietf.org/ipr.$";

    bp["rfc3979_5_p3"] = "The IETF invites any interested party to bring to its attention " \
                      "any copyrights, patents or patent applications, or other " \
                      "proprietary rights that may cover technology that may be required " \
                      "to implement this standard.  Please address the information to the " \
                      "IETF at ietf-ipr@ietf.org.$";

    bp["rfc2026_10_4A"] = "The IETF takes no position regarding the validity or scope of " \
                      "any intellectual property or other rights that might be claimed " \
                      "to pertain to the implementation or use of the technology " \
                      "described in this document or the extent to which any license " \
                      "under such rights might or might not be available; neither does " \
                      "it represent that it has made any effort to identify any such " \
                      "rights.  Information on the IETF\047s procedures with respect to " \
                      "rights in standards-track and standards-related documentation " \
                      "can be found in BCP-11.  Copies of claims of rights made " \
                      "available for publication and any assurances of licenses to " \
                      "be made available, or the result of an attempt made " \
                      "to obtain a general license or permission for the use of such " \
                      "proprietary rights by implement[oe]rs or users of this " \
                      "specification can be obtained from the IETF Secretariat.$";

    bp["rfc2026_10_4B"] = "The IETF invites any interested party to bring to its " \
                      "attention any copyrights, patents or patent applications, or " \
                      "other proprietary rights which may cover technology that may be " \
                      "required to practice this standard.  Please address the " \
                      "information to the IETF Executive Director.$";

    bp["rfc2026_10_4C_p1"] = "Copyright \\([Cc]\\) The Internet Society \\(?[0-9]+\\)?.  All Rights " \
                      "Reserved.$";

    bp["rfc2026_10_4C_p2"] = "This document and translations of it may be copied and " \
                      "furnished to others, and derivative works that comment on or " \
                      "otherwise explain it or assist in its implementation may be " \
                      "prepared, copied, published and distributed, in whole or in " \
                      "part, without restriction of any kind, provided that the above " \
                      "copyright notice and this paragraph are included on all such " \
                      "copies and derivative works.  However, this document itself may " \
                      "not be modified in any way, such as by removing the copyright " \
                      "notice or references to the Internet Society or other Internet " \
                      "organizations, except as needed for the purpose of developing " \
                      "Internet standards in which case the procedures for copyrights " \
                      "defined in the Internet Standards process must be followed, or " \
                      "as required to translate it into languages other than English.$";

    bp["rfc2026_10_4C_p3"] = "The limited permissions granted above are perpetual and will " \
                      "not be revoked by the Internet Society or its successors or " \
                      "assign(ee)?s.$";

    bp["rfc2026_10_4C_p4"] = "This document and the information contained herein is provided " \
                      "on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET " \
                      "ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR " \
                      "IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE " \
                      "OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY " \
                      "IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A " \
                      "PARTICULAR PURPOSE.$";

    bp["rfc2026_10_4D"] = "The IETF has been notified of intellectual property rights " \
                      "claimed in regard to some or all of the specification contained " \
                      "in this document.  For more information consult the online list " \
                      "of claimed rights.$";

    bp["rfc2026_claim"] = "This document is an Internet-Draft and is in full conformance " \
			  "with all provisions of Section 10 of( | \\])RFC( |.?)(2026|2026\\])\\.";

    bp["rfc2026_lax_claim"] = "This document is an Internet-Draft and is in full conformance " \
			  "with all provisions of Section 10 of( | \\])RFC( |.?)(2026|2026\\])( ?\\[[0-9]+\\].*)?.";

    bp["rfc2026b_claim"] = "This document is an Internet-Draft and is subject to all provisions " \
			  "of Section 10 of( | \\])RFC( |.?)(2026|2026\\])\\.";

    bp["rfc2026b_lax_claim"] = "This document is an Internet-Draft and is subject to all provisions " \
			  "of Section 10 of( | \\])RFC( |.?)(2026|2026\\])( ?\\[[0-9]+\\].*)?.";

    bp["rfc3978_3_claim"] = "This document is an Internet-Draft and is subject to all provisions " \
		      "of (S|s)ection 3 of( | \\])RFC( |.?)(3978|3978\\])\\.$";

    bp["rfc2119_p2"]	= "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", " \
			"\"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", " \
			"and \"OPTIONAL\" in this document are to be interpreted as described in" \
			"( | \\[| BCP 14, | BCP 14, \\[)RFC( |.?)2119(\\.|.*\\.|\\].*\\.)$";

    bp["1id_guidelines_p1"] = "Internet-Drafts are working documents of the Internet Engineering " \
			"Task Force \\(IETF\\), its areas, and its working groups.  Note that other " \
			"groups may also distribute working documents as Internet-Drafts.$";

    bp["1id_guidelines_p2"] = "Internet-Drafts are draft documents valid for a maximum of six months " \
			"and may be updated, replaced, or obsoleted by other documents at any " \
			"time.  It is inappropriate to use Internet-Drafts as reference " \
			"material or to cite them other than as \"?work in progress\\.\"?$";

    bp["1id_guidelines_p2a"] = "Internet-Drafts are draft documents valid for a maximum of six months " \
			"and may be updated, replaced, or obsoleted by other documents at any " \
			"time.  It is inappropriate to use Internet-Drafts as reference " \
			"material or to cite them other than as \"?work in progress\"?\\.$";

    bp["1id_guidelines_p3"] = "The list of current Internet-Drafts can be accessed at " \
			"http://www.ietf.org/1id-abstracts.html$";

    bp["1id_guidelines_p3a"] = "The list of current Internet-Drafts can be accessed at:? " \
			"http:// *www.ietf.org/ *(ietf/)?1id-abstracts.(txt|html) ?\\.?$";

    bp["1id_guidelines_p4"] = "The list of Internet-Draft Shadow Directories can be accessed at " \
			"http://www.ietf.org/shadow.html$";

    bp["1id_guidelines_p4a"] = "The list of Internet-Draft Shadow Directories can be accessed at:? " \
			"http:// *www.ietf.org/ *shadow.html ?\\.?$";


}


# ----------------------------------------------------------------------
#   usage()
#

function usage() {
    print "" \
"Usage: idnits [options] filename\n" \
"\n" \
"    Options:\n" \
"	--version	Print the version and exit\n" \
"	--help		Print this text and exit\n" \
"	--nowarn	Don\047t issue warnings, only ID-nits violations\n" \
"	--verbose	Show more information about offending lines\n" \
"	--nitcount	Show a count of nits\n" \
"	--debug		Debug output, especially of boilerplate matching\n" \
"	--year NNNN	Expect the given year in the boilerplate\n" \
""
}


# ----------------------------------------------------------------------
#   strip()
#
function strip(str) {
    sub(/^[ \t\n\r]+/, "", str);
    sub(/[ \t\n\r]+$/, "", str);
    return str;
}

# ----------------------------------------------------------------------
#   get_para()
#
function get_para() {
    para = strip($0);
    while (getline > 0 && (text = strip($0)) != "") {
	if (para ~ /-$/) {
	    para = para text;
	} else {
	    para = para " " text;
	}
    }
    return para;
}

# ----------------------------------------------------------------------
#   match_para()
#
function match_para(para, name1, name2, name3, name4) {
    name[1] = name1; name[2] = name2; name[3] = name3; name[4] = name4;
    for (i=1; i <= 4; i++) {
	pat[i] = bp[name[i]];
    }
    orig = para;
    gsub(/  +/, " ", para);
    pattern = "";
    for (i=1; i <= 4; i++) {
	if (!pat[i]) {
	    almost_boilerplate[name[1]] = orig;
	    return 0;
	}

	gsub(/.  /,".  ?", pat[i]);
	pattern = pattern pat[i];

	if (option_debug && option_pass2) {
	    print "\n----",name[i],"----"
	    print "line", FNR, "\n"
	    print para
	    print ""
	    print pattern
	    print ""
	    if (para ~ pattern) {
		print "** Matches **"
	    } else {
		print "** No Match **"
	    }
	}
	if (para ~ pattern) {
	    for (j=1; j<= i; j++) has[name[j]] = FNR;
	    return 1;
	}
	sub(/ *\$?$/," +", pattern);
    }

    almost_boilerplate[name[1]] = orig;
    return 0
}

# ----------------------------------------------------------------------
#   rindex(str, find)
#
function rindex(str, find,	start, pos, incr, i) {
    start = 0;
    pos = 0;
    incr = length(find);

    while (1) {
	i = index(str, find);
	if ( i == 0 ) return pos;
	pos = start + i;
	str = substr(str, i+incr);
	start = start+i+incr-1;
    }
}

# ----------------------------------------------------------------------
#   fold(str)
#
#   This could have been done by piping through fold, too, but we'd have
#   to postprocess to add indentation anyway, and this should be a lot
#   quicker for short texts.
#
function fold(str, indent, cols,        width) {
    pos = 1;

    #print "str:        ", str;
    #print "indent:     ", indent;
    #print "cols:       ", cols;

    insert = "\n" indent;
    width = cols;
    while (pos+width-1 < length(str)) {
	frag = substr(str, pos, width);
	lpos = rindex(frag, " ");
	if (!lpos) {
	    frag = substr(str, pos+width);
	    lpos = index(frag, " ");
	    if (lpos) lpos += width;
	}
	if (lpos) {
	    #print "** before break :", "..." substr(str, pos+lpos-9, 8)
	    #print "** after  break :", substr(str, pos+lpos, 8) "..."

	    str = substr(str, 1, pos+lpos-2) insert substr(str, pos+lpos);
	    pos = pos + lpos + length(insert);
	} else {
	    return str;
	}
	width = cols - length(indent);
    }
    return str;
}

# ----------------------------------------------------------------------
#   markiff(p1, p2)
#
function markdiff(p1, p2,	prefixlen, para2, suffix, leading, point, temp) {
   prefixlen = 0;
   para2 = p2;
   gsub(/\.  +/, ". ", p1);
   gsub(/\.  +/, ". ", p2);
   do {
      if (substr(p1,1,1) == substr(p2,1,1)) {
	 p1 = substr(p1,2);
	 p2 = substr(p2,2);
      } else {
	 break;
      }
      prefixlen++;
   } while (length(p1) && length(p2));

   prefix = substr(para2,1,prefixlen);
   suffix = substr(para2,prefixlen+1);
   leading = length(prefix) - rindex(prefix, "\n");

   temp = substr(prefix, length(prefix) - leading)
   spacefix = gsub(/\.  +/, ". ", temp);

   point = index(suffix, "\n");
   marker = substr("........................................................................", 1, leading+spacefix) "^\n";
   return prefix substr(suffix, 1, point) marker substr(suffix, point+1)
}

# ----------------------------------------------------------------------
#   expandname(name)
#
function expandname(name) {
    sub(/_p/, " paragraph " , name);
    if (name ~ /^rfc/) {
	sub("_", " Section ", name);
	gsub("_", ".", name);
	sub("rfc", "RFC ", name)
    }
    return name
}

# ----------------------------------------------------------------------
#   showalmost(name)
#
function showalmost(name, orig) {
    p2 = almost_boilerplate[name];
    p2 = fold(p2, "    ",  bpcols);
    p2 = sprintf ("    \"%s\")\n\n", p2)
    if (orig) p2 = markdiff(orig, p2);
    printf(p2)
}
# ----------------------------------------------------------------------
#   showsection(name)
#
function showsection(name, suppress) {
	p = bp[name];
	"date +'%Y'" | getline year
	# Get rid of regexp stuff in the boilerplate text we show the user:
	# - mark metacharacters with mark character "!"
	gsub(/[()|?+*^$]/, "!&", p);
	# - get rid of mark preceeded by escape char...
	gsub(/\\!/, "", p);
	# - get rid of alternates, keeping the first only
	gsub(/!\|[^)]*!\)/, "", p);
	# - and we can get rid of metacharacters not preceeded by escape char
	gsub(/![\(\)?+*^$]/, "", p);
        # and also of escape chars themselves
	gsub(/\\/, "", p);
	# - also say "year" instead of "[0-9]"
	gsub(/\[0-9\]/, "<year>", p);

	if (suppress < 2) announce("  " expandname(name) " text:");
	p1 = fold(p, "    ", bpcols);
	p1 = sprintf("    \"%s\"", p1);
	printf(p1)

	if (name in almost_boilerplate && suppress == 0) {
	    announce( "\n    ... text found in draft:");
	    showalmost(name, p1)
	    print ""
	} else {
	    print "\n";
	}
}

# ----------------------------------------------------------------------
#   checkmultibp(name)
#
function checkmultibp(name) {
    if ( has[name] && almost_boilerplate[name]) {
	warn(sprintf("* In addition to %s boilerplate, a section with a similar start was also found:\n", expandname("rfc3978_5_1")))
	showalmost(name)
    }
}

# ----------------------------------------------------------------------
#   sectionerr(name, str)
#
function sectionerr(name, str, wflag) {
    if (! name in has) {
	print "?? internal error, expected a table match on %s", name;
	exit;
    }
    if (str ~ /^the /) {
	str = "The document seems to lack " str;
    } else if (str ~ /^[aeiouyAEIOUYRH]/) {
	str = "The document seems to lack an " str;
    } else {
	str = "The document seems to lack a " str;
    }
    if (name in almost_boilerplate) {
	str = str " -- however, there\047s a paragraph with a matching beginning. Boilerplate error?";
    } else {
        str = str ". "
    }
    if (wflag) warn(str); else err(str);
    if (option_verbose && option_pass2) {
	showsection(name)
    }
}


# ----------------------------------------------------------------------
#   oldandnewerr(old, new)
#
function oldandnewerr(old, new) {
    if (! new in has) {
	print "?? internal error, expected a table match on %s", new;
	exit;
    }
    newname = expandname(new)
    oldname = expandname(old)
    str = sprintf("Found %s boilerplate (on line %s), which is fine, but *also* found %s boilerplate on line %s. It should be removed.", newname, has[new], oldname, has[old]);
    err(str);
    if (option_verbose && option_pass2) {
	showsection(old, 1)
	showsection(new, 1)
    }
}


# ----------------------------------------------------------------------
# update_references(line)
#
function update_references(this) {
    if (!match(this, /\[Page/)) {
	if ( match(this, /(^|[\]A-Za-z0-9 \t(])\[[0-9A-Z-]+ ?[0-9A-Z-]*\]\)?([) \t,;:.[]|$)/) ) {

	    line[FNR] = $0
	    if (has_refs && !has_appendix) {
		match(this, /\[[0-9A-Z-]+ ?[0-9A-Z-]*\]/)
		reftag = substr(this, RSTART+1, RLENGTH-2)
		ref_def[reftag] = FNR
		if ( ! (reftag in ref_def_seen) ) {
		    ref_def_seen[reftag]; ref_def_list[++ref_def_count] = reftag;
		}
		#printf "	ref_def[%s] = %s\n", reftag, FNR
	    } else {
		while (	match(this, /\[[0-9A-Z-]+ ?[0-9A-Z-]*\]/ )) {
		    tags = substr(this, RSTART+1, RLENGTH-2)
		    split(tags, reftags, /(,|, )/)
		    for (i in reftags) {
			reftag = reftags[i]
			ref_use[reftag] = FNR
			if ( ! (reftag in ref_use_seen) ) {
			    ref_use_seen[reftag]; ref_use_list[++ref_use_count] = reftag;
			}
			#printf "	ref_use[%s] = %s\n", reftag, FNR
		    }
		    this = substr(this, RSTART+RLENGTH)
		}
	    }
	} else if (option_verbose && option_pass1) {
	    match(this, /\[[0-9A-Z-]+\]/)
	    printf("%s(%d): Unexpected reference format: '...%s...'\n", FILENAME, FNR, substr(this,RSTART-5, RLENGTH+10));
	    if (option_verbose > 1) {
		printf("  --> %s\n", this);
		printf("      %*s\n", RSTART, "^");
	    }
	}
    }
}

# ----------------------------------------------------------------------
#   announce()
#

function announce(str) {
    print ""
    print fold("  " str, "  ", columns);
}


# ----------------------------------------------------------------------
#   note()
#

function note(str) {
    print fold("    " str, "    ", columns);
}


# ----------------------------------------------------------------------
#   warn()
#

function warn(str) {
    if (option_warn) {
        print fold("  - " str, "    ", columns);
	warnings++;
    }
}


# ----------------------------------------------------------------------
#   err()
#

function err(str) {
    print fold("  * " str, "    ", columns);
    errors++;
}


# ----------------------------------------------------------------------
#   report()
#

function report(filename) {
    if (skip_file) return;
    if (option_pass1) return;

    if (got_input) {
        is_rfc = (filename ~ /[Rr][Ff][Cc][0-9]+\.txt$/);

	{
	  announce("Checking nits according to http://www.ietf.org/ID-Checklist.html:")
	  warncount = warnings;  errcount = errors;

	  if (!has_abstract)	{ err("The document seems to lack an Abstract section."); }
	  if (!has_intro)	{ err("The document seems to lack an Introduction section."); }
	  if (!has_security)	{ err("The document seems to lack a Security Considerations section."); }
	  if (!has_iana)	{ err("The document seems to lack an IANA Considerations section."); }
	  if (!has_addr)	{ err("The document seems to lack an Authors\047 Addresses Section."); }
	  if (has_refs && ! has_splitrefs)	{ err("The document seems to lack separate sections for Informative/Normative References."); }

	  if (option_list_matches) {
	      print fold("  Boilerplate matches:", "  ", columns)
	      for ( n in has ) {
		  if (n) note(sprintf("Found", n, "on line", has[n]))
	      }
	      print "";
	  }

	  if ( ( has["rfc3667_5_1"]  ||
		 has["rfc3978_5_1_a"] ||
		 has["rfc3978_5_1"] ||
		 has["rfc3978_5_2b"] ||
		 has["rfc3978_5_3"]  ||
		 has["rfc3978_5_5"]  ||
		 has["rfc3979_5_p1"]  ||
		 has["rfc3979_5_p2"]  ||
		 has["rfc3979_5_p3"] ) ) {
						  note("");
						  note("Checking conformance with RFC 3978/3979 boilerplate...\n");
						  non_bp_errs = errors;

	      # Ok, so we have some 3978/3979 boilerplate - make sure we don't *also* have some
	      # lingering old boilerplate...
		 if ( has["rfc3978_5_1"] )  if ( has["rfc3667_5_1"] )	  oldandnewerr("rfc3667_5_1", "rfc3978_5_1");
		 if ( has["rfc3978_5_4_p1"] )if ( has["rfc2026_10_4C_p1"] ) oldandnewerr("rfc2026_10_4C_p1", "rfc3978_5_4_p1");
		 if ( has["rfc3978_5_5"] )  if ( has["rfc2026_10_4C_p4"] ) oldandnewerr("rfc2026_10_4C_p4", "rfc3978_5_5");
		 if ( has["rfc3979_5_p1"] )  if ( has["rfc2026_10_4A"] )   oldandnewerr("rfc2026_10_4A", "rfc3979_5_p1");
		 if ( has["rfc3979_5_p3"] )  if ( has["rfc2026_10_4B"] )   oldandnewerr("rfc2026_10_4B", "rfc3979_5_p3");


	      if ( has["rfc2026_lax_claim"] ||
		 has["rfc2026b_lax_claim"] )
				      {
					  err(  "The document claims conformance with section 10 of RFC 2026, but uses " \
						"some RFC 3978/3979 boilerplate.  As RFC 3978/3979 replaces section 10 of " \
						"RFC 2026, you should not claim conformance with it if you have changed " \
						"to using RFC 3978/3979 boilerplate.");
				      }

	      if (!(has["rfc3978_5_1"]) && !is_rfc )
				      {
					  sectionerr("rfc3978_5_1", "RFC 3978 Section 5.1 IPR Disclosure Acknowledgement");
				      }
	      if ( has["rfc3978_5_2b"]) { err("The document has an RFC 3978 Section 5.2(b) Derivative Works Limitation clause."); }
	      if ( has["rfc3978_5_3"])  { err("The document has an RFC 3978 Section 5.3 Publication Limitation clause ."); }
	      if (!has["rfc3978_5_4_p1"])  {
					  sectionerr("rfc3978_5_4_p1", "RFC 3978 Section 5.4 Copyright Line");
				      }
	      if (!has["rfc3978_5_4_p2"]) {
					  sectionerr("rfc3978_5_4_p2", "RFC 3978 Section 5.4 Reference to BCP 78");
					}
	      if (!has["rfc3978_5_5"])  { sectionerr("rfc3978_5_5", "RFC 3978 Section 5.5 Disclaimer"); }
	      if (! has["rfc3979_5_p1"]) {
					  sectionerr("rfc3979_5_p1", "RFC 3979 Section 5, para 1 IPR Disclosure Acknowledgement");
					  if (has["rfc2026_10_4A"]) {
						  note("( - It does however have an RFC 2026 Section 10.4(A) Disclaimer.)");
					  }
					}
	      if (! has["rfc3979_5_p2"]) {
					  sectionerr("rfc3979_5_p2", "RFC 3979 Section 5, para 2 IPR Disclosure Acknowledgement");
					}
	      if (! has["rfc3979_5_p3"]) {
					  sectionerr("rfc3979_5_p3", "RFC 3979 Section 5, para 3 IPR Disclosure Invitation");
					  if (has["rfc2026_10_4B"]) {
						  note("( - It does however have an RFC 2026 Section 10.4(B) IPR Disclosure Invitation.)");
					  }
				      }
	      if ( has["rfc3667_3_claim"] || (has["rfc3667_5_1"] || has["rfc3978_5_1_a"]) && !has["rfc3978_5_1"])	{
					  err("The document uses RFC 3667 boilerplate or RFC 3978-like " \
					       "boilerplate instead of verbatim RFC 3978 boilerplate.  After 6 May 2005, " \
					       "submission of drafts without verbatim RFC 3978 boilerplate is not " \
					       "accepted.\n");

					  note("The following non-3978 patterns matched text found in the document.  That text should be removed or replaced:\n")
					  if (has["rfc3667_3_claim"]) showsection("rfc3667_3_claim", 2)
					  if (has["rfc3667_5_1"]) showsection("rfc3667_5_1", 2)
					  if (has["rfc3978_5_1_a"] && !has["rfc3978_5_1"]) showsection("rfc3978_5_1_a", 2)

				      }
				      if ( errors == non_bp_errs ) {
					  note("the boilerplate looks good.\n");
				      }

	  } else if (( has["rfc2026_lax_claim"] ||
		has["rfc2026b_lax_claim"] ||
		has["rfc2026_10_4C_p2"] ||
		has["rfc2026_10_4C_p3"] ||
		has["rfc2026_10_4C_p4"] ) ) {
					  if (option_verbose) {
					      print "";
					      if (has["rfc2026_lax_claim"] || has["rfc2026b_lax_claim"])
						  note("  [Claims RFC 2026 conformance...]")
					      if (has["rfc2026_10_4C_p1"])
						  note("  [Has RFC 2026 Sec. 10.4 para. 1...]")
					      if (has["rfc2026_10_4C_p2"])
						  note("  [Has RFC 2026 Sec. 10.4 para. 2...]")
					      if (has["rfc2026_10_4C_p3"])
						  note("  [Has RFC 2026 Sec. 10.4 para. 3...]")
					      if (has["rfc2026_10_4C_p4"])
						  note("  [Has RFC 2026 Sec. 10.4 para. 4...]")
					      print "";
					  }
					  err("Looks like you\047re using RFC 2026 boilerplate. Better change to RFC 3978/3979.");
	      if ( option_2026 ) {
		  if ( ref_in_heading_nit)  { err("The document seems to add a numbered reference to RFC 2026 to the boilerplate."); }

		  if (!has["rfc2026_10_4C_p1"]) { sectionerr("rfc2026_10_4C_p1", "RFC 2026 Section 10.4(C) Copyright Notice"); }
		  if (!has["rfc2026_10_4C_p2"] ||
		      !has["rfc2026_10_4C_p3"]) { sectionerr("rfc2026_10_4C_p2", "RFC 2026 Section 10.4(C) Permission Grants Notice"); }
		  if (!has["rfc2026_10_4C_p4"]) { sectionerr("rfc2026_10_4C_p4", "RFC 2026 Section 10.4(C) Disclaimer"); }

	      }
	  } else {
	      errors += 7;
	      err("Cannot find any IPR, Copyright or other required boilerplate in this document.");
	  }

	  # According to the nits page we should be comparing to 15 here, but
	  # that may be without the boilerplate - and practice seems to permit
	  # also 16 pages including boilerplate, so...
	  if (!has_toc && ((pagecount > 16) || (FNR > 50*16))) {
	      err("The document is more than 15 pages and seems to lack a Table of Contents.");
	  }
	  if (spacing > 50) {
	      if (!option_verbose) err(sprintf("There %s %d instance%s of weird spacing in the document.  " \
				"Is it really formatted ragged-right, rather than justified?", \
				(spacing==1?"is":"are"), spacing, (spacing==1?"":"s") ));
	  }

	  if (longlines) {
	      if (!option_verbose) err(sprintf("There %s %d instance%s of too long lines in the document, " \
		               "the longest one being %d character%s in excess of 72.", \
				(longlines==1?"is":"are"), longlines, (longlines==1?"":"s"), \
				excesslength, ((excesslength > 1) ? "s" : "")));
	  }

	  if (nonascii) {
	      if (!option_verbose) err(sprintf("There %s %d instance%s of lines with non-ascii characters in the document.", \
				(nonascii==1?"is":"are"), nonascii, (nonascii==1?"":"s") ));
	  }

	  if (controlchars) {
	      if (!option_verbose) err(sprintf("There %s %d instance%s of lines with control characters in the document.", \
				(controlchars==1?"is":"are"), controlchars, (controlchars==1?"":"s") ));
	  }

	  if (badfqdns) {
	      if (!option_verbose) err(sprintf("There %s %d instance%s of lines with non-RFC2606-compliant FQDNs in the document.", \
				(controlchars==1?"is":"are"), badfqdns, (badfqdns==1?"":"s") ));
	  }

	  if (warncount == warnings && errcount == errors) note("No nits found.");
	}

	if ( !is_rfc ) {
	  announce("Checking nits according to http://www.ietf.org/ietf/1id-guidelines.txt:");
	  warncount = warnings; errcount = errors;

	  if (!has["1id_guidelines_p1"]) { sectionerr("1id_guidelines_p1", "1id_guidelines paragraph about Internet-Drafts being working documents"); }
	  if (!(has["1id_guidelines_p2"] ||
		has["1id_guidelines_p2a"])) { sectionerr("1id_guidelines_p2", "1id_guidelines paragraph about 6 months document validity"); }
	  if (!(has["1id_guidelines_p3"] ||
		has["1id_guidelines_p3a"])) { sectionerr("1id_guidelines_p3", "1id_guidelines paragraph about the list of current Internet-Drafts"); }
	  if (!(has["1id_guidelines_p4"] ||
		has["1id_guidelines_p4a"])) { sectionerr("1id_guidelines_p4", "1id_guidelines paragraph about the list of Shadow Directories"); }

	  if (has_docname) {
	      file_docname = option_filename
	      sub(".*/", "", file_docname)
	      sub(/\..*$/, "", file_docname)

	      if (good_docname != full_docname) {
		  err(sprintf("Bad filename characters: the document name given in the document, '%s', contains other characters than digits, lowercase letters and dash.", full_docname))
	      }

	      if ( ! match(full_docname, /.*-[0-9][0-9]$/) ) {
		  err(sprintf("Missing revision: the document name given in the document, '%s', does not give the document revision number", full_docname))
	      }

	      if (length(file_docname) > length(full_docname)) long_docname = file_docname; else long_docname = full_docname;
	      sub(/-[0-9][0-9]$/, "", long_docname);
	      if (length(long_docname) > 50) {
		  err(sprintf("Too long document name: The document name (without revision number), '%s', is %d characters long, but may be at most 50 characters", long_docname, length(long_docname)))
	      }

	      if (file_docname != full_docname) {
		  warn(sprintf("Mismatching filename: the document gives the document name as '%s', but the file name used is '%s'", full_docname, file_docname))
	      }

	  } else {
	      err("Expected the document's filename to be given on the first page, but didn't find any");
	  }

	  if ( maxpagelength > 58 ) {
	      warn(sprintf("The page length should not exceed 58 lines per page, " \
	                   "but there was %d longer page%s, the longest (page %d) being %d lines", longpagecount, (longpagecount==1?"":"s"), longestpage, maxpagelength));
	  }
	  if ( pagecount > formfeedcount+1 ) {
	      warn(sprintf("It seems as if not all pages are separated by form feeds - " \
	                   "found %d form feeds but %d page%s", formfeedcount, pagecount, (pagecount==1?"":"s")));
	  }

	  if (warncount == warnings && errcount == errors)
          note("Nothing found here (but these checks do not cover all of 1id-guidelines.txt yet).");
	}

	# --------------------------------------------------------------
	# Warnings

	{
	  announce("Miscellaneous warnings:")
	  warncount = warnings; errcount = errors;
	  warnshere = warnings;

	  checkmultibp("rfc3978_5_1");
	  checkmultibp("rfc3978_5_2b");
	  checkmultibp("rfc3978_5_3");
	  checkmultibp("rfc3978_5_5");
	  checkmultibp("rfc3979_5_p1");
	  checkmultibp("rfc3979_5_p2");
	  checkmultibp("rfc3979_5_p3");

	  if ( ( has["rfc2026_lax_claim"] ||
		 has["rfc2026b_lax_claim"] ) &&

	       ( has["rfc2026_10_4C_p2"] ||
		 has["rfc2026_10_4C_p3"] ||
		 has["rfc2026_10_4C_p4"] ) ) {
		  if (option_rfc2026) {

	      if (!has["rfc2026_10_4A"]  ) {	warn("The document seems to lack an RFC 2026 Section 10.4(A) Disclaimer."); }
	      if (!has["rfc2026_10_4B"]  ) {    warn("The document seems to lack an RFC 2026 Section 10.4(B) IPR Disclosure Invitation."); }
	      if ( has["rfc2026_10_4D"])   {    warn("The document has an RFC 2026 Section 10.4(D) IPR Notice."); }

		  }
	  }
	  if ( has["rfc3978_5_2a"])  {          warn("The document has an RFC 3978 Section 5.2(a) Derivative Works Limitation clause."); }
	  if ( has["rfc3978_5_4_p1"] &&
	      !has["rfc3978_5_4_p1_now"])  {	warn("The copyright year in the RFC 3978 Section 5.4 Copyright Line does not match the current year"); }
	  if ( has["rfc3978_5_4_p1_old"] &&
	       has["rfc3978_5_4_p1_now"])  {	warn(sprintf("The copyright year in the RFC 3978 Section 5.4 Copyright around line %s does not match the year around line %s",
							     has["rfc3978_5_4_p1_old"], has["rfc3978_5_4_p1_now"]));
					   }

	  if (!option_verbose && hyphens && !is_rfc) {
	      warn(sprintf("There %s %d instance%s of lines with hyphenated line breaks in the document.", \
			   (hyphens==1?"is":"are"), hyphens, (hyphens==1?"":"s")));
	  }

	  if ( misspelled_toc )	{ warn("The \"Table of Contents\" section title seems to be misspelled."); }

	  if ( misspelled_addr ) { warn("The \"Author\047s Address\" (or \"Authors\047 Addresses\") section title is misspelled."); }

	  if (!option_verbose && spacing) {
	      for (i=1; i<=5; i++) {
		  if (i in sp_line)
		      warn(sprintf("Line %d has weird spacing: \047...%s...\047", linenum[i], extract[i]));
	      }
	      if (spacing > 5)
		  warn(sprintf("(%d more instance%s...)",spacing-5, (spacing-5==1?"":"s")));
	  }

	  if ( keywords && !has["rfc2119_p2"] ) { sectionerr("rfc2119_p2", "the recommended RFC 2119 boilerplate, even if it appears to use RFC 2119 keywords", 1); }

	  if (warncount == warnings && errcount == errors) note("None.");


	  announce("Experimental warnings:")
	  warncount = warnings; errcount = errors;
	  warnshere = warnings;

	  for ( i = 1; i <= ref_use_count; i++ ) {
	      tag = ref_use_list[i]
	      if (! (tag in ref_def)) {
		  warn(sprintf("Missing Reference: '%s' is mentioned on line %s, but not defined", tag, ref_use[tag]))
		  if (option_verbose) printf "    '%s...'\n\n", substr(line[ref_use[tag]],1,70);
	      }
	  }
	  for ( i = 1; i <= ref_def_count; i++ ) {
	      tag = ref_def_list[i]
	      if (! (tag in ref_use)) {
		  warn(sprintf("Unused Reference: '%s' is defined on line %s, but not referenced", tag, ref_def[tag]))
		  if (option_verbose) printf "    '%s'\n\n", line[ref_def[tag]];
	      }
	  }

	  if (warncount == warnings && errcount == errors) note("None.");
	}

	# --------------------------------------------------------------
	# Summary

	if (errors == 0) {
	    print "";
	    note("No nits found.");
	} else {
	    if (option_nitcount) {
	        print "";
	        note(sprintf("Summary: %d nit%s, %d warning%s", errors, (errors==1?"":"s"), warnings, (warnings==1?"":"s")));
	    }
	    if (! option_verbose) {
	        print "";
		note("Run idnits with the --verbose option for more detailed information.");
	    }
	}
    }
}


# ----------------------------------------------------------------------
#  Pattern / actions:
#

/^This Internet-Draft(, draft-.*)? has been deleted./ {
    if (option_pass2) printf "  Skipping this file; it looks like a tombstone file to me.\n";
    skip_file = 1;
}

/^This +document has been replaced by/ {
    if (option_pass2) printf "  Skipping this file; it looks like a tombstone file to me.\n";
    skip_file = 1;
}

/^This Internet-Draft(, draft-.*)? was published as/ {
    if (option_pass2) printf "  Skipping this file; it looks like a tombstone file to me.\n";
    skip_file = 1;
}

/^A new Request for Comments is now available/ {
    if (option_pass2) printf "  Skipping this file; it looks like a tombstone file to me.\n";
    skip_file = 1;
}

/^RFC [0-9]+ was never issued./ {
    if (option_pass2) printf "  Skipping this file; it looks like a tombstone file to me.\n";
    skip_file = 1;
}

/.*/ {
    got_input = 1;

    gsub(/\r/,"");
    sub(/[\n\t ]+$/, "");
    thiscolumn = match($0, /[^ ]/);
    if (thiscolumn && thiscolumn < indentation) indentation = thiscolumn;

    # 1.1.a	Max column 72
    if (length($0) > 72 && ! skip_file) {
	if (option_verbose && option_pass1) {
	    printf("%s(%d): Line is too long: the offending characters are \047%s\047\n", FILENAME, FNR, substr($0,73));
	}
	longlines++;
	if (length($0) - 72 > excesslength) {
	    excesslength = length($0) - 72;
	}
    }

    # 1.1.b	Ragged right
    if (! skip_file  && ! match($0, /^ *Internet.Draft/)  && ! match($0, /^ *INTERNET.DRAFT/) && match($0, /[A-Za-z][a-z]   ? ?[a-z]/) ) {
	if (option_verbose && option_pass1 ) {
	    printf("%s(%d): Line has weird spacing: \047...%s...\047\n", FILENAME, FNR, substr($0, RSTART-5, 14));
	}
	spacing++;
	sp_line[spacing] = $0;
	linenum[spacing] = FNR;
	extract[spacing] = substr($0, RSTART-5, 14)

    }

    # 1.1.c	No hyphenation for line-breaks
    if ( $0 ~ /[A-Za-z0-9_]-$/ && ! skip_file && ! has_refs && has_hyphenlist ) {
	word = $0
	sub(/^.*[^A-Za-z0-9_-]/, "", word)
	if ( ! word in hyphenfrags ) {
	    if (option_verbose && option_pass1) {
		printf("%s(%d): Line seems to end with a hyphenated word.\n", FILENAME, FNR)
		if (option_verbose > 1 && option_pass1) {
		    printf("  --> %s\n", $0);
		}
	    }
	   hyphens++
	}
    }

    # 1.1.e	ASCII-only
    # The test really should go from \200 to \377 - but the awk implementation
    # on *BSD seems to have used \377 internally as a sentinel or something...
    if (match($0, "[^\001-\177]") && ! skip_file) {
	if (option_verbose && option_pass1) {
	    printf("%s(%d): Line contains a non-ascii character (%s) in position %d.\n", FILENAME, FNR, substr($0, RSTART,1), RSTART);
	    if (option_verbose > 1 && option_pass1) {
		printf("  --> %s\n", $0);
		printf("      %*s\n", RSTART, "^");
	    }
	}
	nonascii++;
    }
    # 1.1.e	no control characer except CR NL FF
    #  nawk can't handle octal escapes inside character classes, it seems.  Sigh.
    #if (match($0, /[\001-\011\013\016-\037]/) && ! skip_file) {
    if (match($0, /(\001|\002|\003|\004|\005|\006|\007|\010|\011|\013|\016|\017|\020|\021|\022|\023|\024|\025|\026|\027|\030|\031|\032|\033|\034|\035|\036|\037)/) && ! skip_file) {
	if (option_verbose && option_pass1) {
	    printf("%s(%d): Line contains control character %s in position %d.\n", FILENAME, FNR, controlchar[substr($0, RSTART, 1)], RSTART);
	    if (option_verbose > 1 && option_pass1) {
	        printf("  --> %s\n", $0);
	        printf("      %*s\n", RSTART, "^");
	    }
	}
	controlchars++;
    }

    # 1.1.f	Do not number the Abstract section
    if ( $0 ~ /^[ \t]*Abstract[ \t]*$/ ) {
	abstract_seen = 1;
    }
    if ( $0 ~ /^[ \t]*[0-9][.0-9 \t]*Abstract[ \t]*$/ && ( ! abstract_seen ) && ! skip_file && option_pass2) {
	printf("  The Abstract section seems to be numbered\n");
	abstract_seen = 1;
	errors++;
    }

    # 1.1.f	Do not number the "Status of Memo" section
    if ( $0 ~ /^[ \t]*Status of Memo[ \t]*$/ ) {
	status_of_memo_seen = 1;
    }
    if ( $0 ~ /^[ \t]*[0-9][.0-9 \t]*Status of Memo[ \t]*$/ && ( ! status_of_memo_seen ) && ! skip_file && option_pass2) {
	printf("  The Status of Memo section seems to be numbered\n", FNR);
	status_of_memo_seen = 1;
	errors++;
    }

    # RFC 2119 language    
    if ( match($0, /[ \t\r\n](MUST|MUST NOT|REQUIRED|SHALL|SHALL NOT|SHOULD|SHOULD NOT|RECOMMENDED|MAY|OPTIONAL)[ \t\r\n\.,]/ ) )	{
	keywords++;
	#if (option_verbose > 1 && option_pass1) {
	#    printf("%s(%d): Line contains RFC 2119 language in position %d.\n", FILENAME, FNR, RSTART+1);
	#    printf("  --> %s\n", $0);
	#    printf("      %*s\n", RSTART+1, "^");
	#}
    }

    # ID-Checklist section 3.6 A:
    if ( has_intro && !has_refs && match($0, /[ \t]([A-Za-z0-9_-]+\.)+[A-Za-z0-9_-]+\.[A-Za-z]+/) ) {
	FQDNSTART = RSTART
	FQDNLENGTH = RLENGTH
	FQDN = substr($0, RSTART+1, RLENGTH-1)
	
	if (!match(FQDN, /([a-z0-9_-]+\.)+example(.(com|org|net))?/) && FQDN !~ /www.ietf.org/ &&  FQDN !~ /[0-9]+\.[0-9]+\./ && FQDN !~ /.\..\../ ) {
	    if (option_verbose && option_pass1) {
		printf("%s(%d): Line contains FQDN '%s' in position %d; this doesn't match RFC2606's suggested \".example\" or \".example.(com|org|net)\".\n", FILENAME, FNR, FQDN, FQDNSTART)
		if (option_verbose > 1 && option_pass1) {
		    printf("  --> %s\n", $0);
		    printf("      %*s\n", FQDNSTART, "^");
		}
	    }
	    badfqdns++;
	}
    }
}

# Pagecount
/-\+- Pagecount: [0-9]+ -\+-/	  { pagecount = $3+0; next  }
/-\+- Maxpagelength: [0-9]+ -\+-/ { maxpagelength = $3+0; next  }
/-\+- Longestpage: [0-9]+ -\+-/	  { longestpage = $3+0; next  }
/-\+- Longpagecount: [0-9]+ -\+-/ { longpagecount = $3+0; next  }
/-\+- Formfeedcount: [0-9]+ -\+-/ { formfeedcount = $3+0; next  }

# Check for required sections
# Nawk doesn't understand IGNORECASE = 0, so we have to explicitly convert.
# Also normalise the indentation
								{
								    normalized = tolower($0);
								    if (indentation) normalized = substr(normalized, indentation);
								}
normalized ~ /^[0123.]* *abstract$/				{   has_abstract = 1; }
normalized ~ /^[0123.]* *table of contents:?$/			{   has_toc = 1; in_toc = 1; }
normalized ~ /^[ \t]*contents$/					{   if (!has_intro) has_toc = 1; in_toc = 1; }
normalized ~ /\. ?\. ?\. ?\. ?\. ?\. ?\. ?\. ?\. ?\. ?[0-9]+$/	{   if (!has_intro) has_toc = 1; in_toc = 1; }
normalized ~ /^[0123.]* *introduction[ \t]*.*/			{   has_intro = 1; }
normalized ~ /^[0123.]* *overview[ \t]*.*/			{   has_intro = 1; }
normalized ~ /^[0123.]* *rationale[ \t]*.*/			{   has_intro = 1; }
normalized ~ /^[0123.]* *scope[ \t]*.*/				{   has_intro = 1; }
normalized ~ /^[0123.]* *(historical )?background[ \t]*.*/ 	{   has_intro = 1; }
normalized ~ /^[0-9.]* *security considerations?[ \t]*.*/	{   has_security = 1; }
normalized ~ /^[0-9.]* *security$/				{   has_security = 1; }
normalized ~ /^[0-9a-z.]* *iana considerations?[ \t]*.*/	{   has_iana = 1; }
normalized ~ /^[0-9a-z.]* *references$/			{   if (has_intro || has_security || has_iana) { has_refs = 1; }}
normalized ~ /^ *[0-9a-z.]* *normative references?$/		{   if (has_intro || has_security || has_iana) { has_splitrefs = 1; has_refs = 1; }}
normalized ~ /^ *[0-9a-z.]* *informative references?$/		{   if (has_intro || has_security || has_iana) { has_splitrefs = 1; has_refs = 1; }}
normalized ~ /^ *[0-9a-z.]* *references[^a-z]+normative?$/	{   if (has_intro || has_security || has_iana) { has_splitrefs = 1; }}
normalized ~ /^ *[0-9a-z.]* *references[^a-z]+informative?$/	{   if (has_intro || has_security || has_iana) { has_splitrefs = 1; }}
normalized ~ /^ *[0-9a-z.]* *normative$/			{   if (has_refs) has_splitrefs = 1; }
normalized ~ /^ *[0-9a-z.]* *informative$/			{   if (has_refs) has_splitrefs = 1; }
normalized ~ /^[0-9a-z.]* *((author|editor)(\047s|s\047) +(and +)?)+address(es)?/{   has_addr = 1; }
normalized ~ /^[0-9a-z.]* *author information$/			{   has_addr = 1; }
normalized ~ /^[0-9a-z.]* *(author|editor)(\047s|s\047) contact information$/	{   has_addr = 1; }
normalized ~ /^[0-9A-Z.]* *contact information$/		{   has_addr = 1; }
normalized ~ /^[0-9A-Z.]* *appendix/				{   if (has_refs) has_appendix = 1; }

# RFC 3978 / 2026 compliance
/By submitting this Internet-Draft/                             {
								    para = get_para()
                                                                    match_para(para, "rfc3667_5_1")
								    match_para(para, "rfc3978_5_1");
                                                                    match_para(para, "rfc3978_5_1_a")
                                                                }
/This document may not be modified/                             {
								    para = get_para()
                                                                    match_para(para, "rfc3978_5_2a") ||
								    match_para(para, "rfc3978_5_2ax");
                                                                    match_para(para, "rfc3978_5_2b") ||
								    match_para(para, "rfc3978_5_2bx");
                                                                }
/^[ \t0-9.]*This document may only be posted in an Internet-Draft.$/ {   has["rfc3978_5_3"] = FNR; }
/Copyright ?\([Cc]\) ?The Internet Society/                       {
								    para = get_para()
								    has_some_year = match_para(para, "rfc3978_5_4_p1", "rfc3978_5_4_p2");
								    has_this_year = match_para(para, "rfc3978_5_4_p1_now");
                                                                    match_para(para, "rfc2026_10_4C_p1", "rfc2026_10_4C_p2", "rfc2026_10_4C_p3", "rfc2026_10_4C_p4");
								    if (has_some_year && !has_this_year) has["rfc3978_5_4_p1_old"] = FNR;
                                                                }
/This document is subject to the rights/			{
								    para = get_para()
								    match_para(para, "rfc3978_5_4_p2");
								}
/This document and the information/                             {
								    para = get_para()
                                                                    match_para(para, "rfc3978_5_5");
                                                                    match_para(para, "rfc2026_10_4C_p4");
                                                                }
/The IETF takes no position regarding/                          {
								    para = get_para()
                                                                    match_para(para, "rfc3979_5_p1", "rfc3979_5_p2", "rfc3979_5_p3");
                                                                    match_para(para, "rfc2026_10_4A");
                                                                }
/Copies of IPR disclosures made to the/                         {
								    para = get_para()
								    match_para(para, "rfc3979_5_p2", "rfc3979_5_p3");
								}
/The IETF invites any interested party/                         {
								    para = get_para()
                                                                    match_para(para, "rfc3979_5_p3");
                                                                    match_para(para, "rfc2026_10_4B");
                                                                }
/This document and translations of it/                          {
								    para = get_para()
                                                                    match_para(para, "rfc2026_10_4C_p2", "rfc2026_10_4C_p3", "rfc2026_10_4C_p4");
                                                                }
/The limited permissions granted above/                         {
								    para = get_para()
                                                                    match_para(para, "rfc2026_10_4C_p3", "rfc2026_10_4C_p4");
                                                                }
/The IETF has been notified of intellectual/                    {
								    para = get_para()
                                                                    match_para(para, "rfc2026_10_4D");
                                                                }

/This document is an Internet-Draft and is/			{
								    para = get_para()
								    match_para(para, "rfc2026_lax_claim");
								    match_para(para, "rfc2026b_lax_claim");

								    ref_in_heading_nit	= ( has["rfc2026_lax_claim"] ||
											    has["rfc2026_lax_claim"] ) &&
											! match_para(para, "rfc2026_claim") &&
											! match_para(para, "rfc2026b_claim");

								    match_para(para, "rfc3667_3_claim", "rfc3667_5_1" );
								    match_para(para, "rfc3667_3_claim", "rfc3978_5_1_a" );
								    match_para(para, "rfc3978_3_claim", "rfc3667_5_1" );
								    match_para(para, "rfc3978_3_claim", "rfc3978_5_1");
								    match_para(para, "rfc3978_3_claim", "rfc3978_5_1_a");
								}

# RFC 2119 compliance
/([Tt]he key ?words|In this document, several words are used)/	{
								    para = get_para()
								    match_para(para, "rfc2119_p2");

								    if (match( para, /\[[0-9A-Z, -]+\]/ )) {
									reftag = substr(para, RSTART+1, RLENGTH-2);
								    } else {
									reftag = "RFC2119"
								    }
								    ref_use[reftag] = FNR;
								    line[FNR] = para;
								    if ( ! (reftag in ref_use_seen) ) {
									ref_use_seen[reftag]; ref_use_list[++ref_use_count] = reftag;
								    }
								}

#/^[ \t0-9.]*Table Of [Cc]ontents?:?$/			{   has_toc = 1; misspelled_toc = 1}
/^[ \t0-9.]*(Author|Editor)([^\047]s|s[^\047]) [Aa]ddress(es)?$/	{   has_addr = 1; misspelled_addr = 1; }
/^[ \t0-9.]*(Authors?|Editors?) +[Aa]ddress(es)?$/	{   has_addr = 1; misspelled_addr = 1; }

# 1id_guidelines.html compliance
/Internet-Drafts are working documents of/			{
								    para = get_para()
                                                                    match_para(para, "1id_guidelines_p1", "1id_guidelines_p2", "1id_guidelines_p3a", "1id_guidelines_p4a") ||
                                                                    match_para(para, "1id_guidelines_p1", "1id_guidelines_p2a", "1id_guidelines_p3a", "1id_guidelines_p4a");
                                                                }
/Internet-Drafts are draft documents valid for/			{
								    para = get_para()
                                                                    match_para(para, "1id_guidelines_p2", "1id_guidelines_p3a", "1id_guidelines_p4a") ||
								    match_para(para, "1id_guidelines_p2a", "1id_guidelines_p3a", "1id_guidelines_p4a");
                                                                }
/The list of current Internet-Drafts can be/			{
								    para = get_para()
                                                                    match_para(para, "1id_guidelines_p3", "1id_guidelines_p4a") ||
                                                                    match_para(para, "1id_guidelines_p3a", "1id_guidelines_p4a");
                                                                }
/The list of Internet-Draft Shadow Directories/			{
								    para = get_para()
                                                                    match_para(para, "1id_guidelines_p4") ||
                                                                    match_para(para, "1id_guidelines_p4a");
                                                                }

/draft-/							{
								    if ( !has_intro && !has_abstract && !has_refs && !has_appendix && !has_docname) {
									match($0, /draft-[a-z0-9-]*/)
									good_docname = substr($0, RSTART, RLENGTH)
									match($0, /draft-[^. \t>]*/)
									full_docname = substr($0, RSTART, RLENGTH)
									has_docname = 1
								    }
								}

# References
/\[[0-9A-Z-]+ ?[0-9A-Z-]*\]/					{
								    update_references($0)
								}
/\[[0-9A-Z-]+- *$/						{
								    incomplete_ref_line = strip($0)
								    incomplete_ref_pos  = FNR
								}
/^ *[0-9A-Z-]+\]/						{
								    if (incomplete_ref_pos+1 == FNR) {
									update_references(incomplete_ref_line strip($0))
								    }
								}
								

END {

    report(option_filename);
    if (errors || longlines || hyphens || spacing || nonascii || controlchars )  print "";
    if (total_errors < 256) {
	exit total_errors;
    } else {
       exit 255;
    }
}
EOF

    $AWK -f $program $*
    if [ ! "$optkeep" = "1" ]; then
	rm -f $program
    fi
}

helpmsg() {
	  echo "
Usage: idnits [options] filename

    Options:
	--version	Print the version and exit
	--help		Print this text and exit
	--nowarn	Don\047t issue warnings, only ID-nits violations
	--verbose	Show more information about offending lines
	--nitcount	Show a count of nits
	--debug		Debug output, especially of boilerplate matching
	--year NNNN	Expect the given year in the boilerplate (instead
			of the current year)

'idnits' looks for violations of Section 2.1 and 2.2 of the
requirements listed on http://www.ietf.org/ID-Checklist.html

idnits works on Linux, OS-X, Windows under Cygwin, on *BSD and may work on
Solaris.  Testing on *BSD and Solaris has been minimal, though.  To install,
simply download the script, place it in your path and make it executable.
idnits uses awk and sh internally.

Many, but not all ID-nits are checked; here's the list:

1.1 Formatting

yes  * Not beyond the 72nd column of a line
       This is especially important for diagrams and code, which the RFC Editor
       may not be able to trivially reformat to fall within the margins.
yes  * Must be ragged right
     * No hyphenation for line-breaks
     * No footnotes
yes  * ASCII-only, no control characters (other than CR, NL & FF)
yes  * Do not number the \"Status of Memo\" or Abstract sections
yes@ * Do not add a numbered reference in the ID boilerplate to RFC 3978 or 3979
       (makes it harder for the RFC editor to process the document when they
       strip off the ID boilerplate)
     * Reasonably well formatted for readibility and clarity.
     * Use network byte order in diagrams
       (see draft-rfc-editor-rfc2223bis-07.txt section 3.4)

1.2 Required sections - all IDs

yes@ * Internet Draft boilerplate
       Must contain boilerplate that permits publication as an RFC
       (see RFC3978, Section 5.2.)
     * List of authors/editors
       There should not be > 5 authors/editors
       (see http://www.rfc-editor.org/policy.html)
yes  * Abstract
yes  * Table of Contents, required if document is more than 15 pages
yes  * Introduction
yes  * Security Considerations
yes  * IANA Considerations
yes  * References
       Must be split into normative and informative sections
       (see http://www.rfc-editor.org/policy.html)
yes  * Author's Address
yes  * IPR notices, IPR Notice, verbatim from RFC3979, Section 5.
yes  * Copyright Notice and Disclaimer,
       verbatim from RFC3978, Sections 5.4 and 5.5.


------------------------------------------------------------------------
 @: Interpreted in light of the new requirements introduced by RFC 3667
    (replaced by 3978) and RFC 3668 (replaced by 3979:

yes * IPR Disclosure Acknowledgement per RFC 3978 Section 5.1
yes * No Derivative Works Limitation clause per RFC 3978 Section 5.2(b)
yes * No Publication Limitation clause per RFC 3978 Section 5.3
yes * Copyright Notice per RFC 3978 Section 5.4
yes * Disclaimer per RFC 3978 Section 5.5
yes * Disclaimer of IPR validity per RFC 3979 Section 5

"
}

while [ $# -gt 0 ]; do
    case "$1" in
	--version)
            echo "idnits	$version"
	    exit
	    ;;
	--help)
	    helpmsg
	    exit
	    ;;
	--verbose)
	    optverbose="$optverbose $1"
	    options="$options $1"
	    ;;
	--keep)
	    optkeep=1
            ;;
	--width)
	    optwidth=$2
	    shift
	    ;;
	--year)
	    options="$options $1 $2"
	    shift
	    ;;
	--) shift;
	    files="$files $*"
	    break
	    ;;
	-*) options="$options $1"
	    ;;
	*)  files="$files $1"
	    ;;
    esac
    shift
done

echo "idnits $version $progdate"

if [ "$optwidth" ]; then
   COLUMNS=$optwidth
elif [ -z $COLUMNS ]; then
   SIZE=$(stty size 2>/dev/null)
   if [ "$SIZE" ]; then
       set $SIZE
       LINES=$1
       COLUMNS=$2
   fi
fi

export CHECKNITS COLUMNS

if [ -z "$files" ]; then
    CHECKNITS=$options
    strip | checknits
else
    for file in $files; do
	echo ""
	echo "$file:"
	echo ""

	if [ "$optverbose" ]; then
	    # run a first pass without stripping, to get correct line
	    # numbers in the verbose reports
	    (CHECKNITS="$optverbose --pass1" checknits $file)
	fi

	CHECKNITS="$options --filename $file"
	if [ "$optkeep" = "1" ]; then
	    strip $file | tee /tmp/idnits-$$-stripped-`basename $file` | checknits
	else
	    strip $file | checknits
	fi
    done
fi

